

\chapter{Fejlesztői dokumentáció}
\label{ch:impl}


\section{Megoldandó feladat}
\section{Használt eszközök és környezetek} \label{usedTechnologies}
\subsection{Erlang nyelv}
Az 1980-as évek közepén az Ericsson Számítógép Laboratóriuma azt a feladatot kapta, hogy alkossa meg azt a platformot, ami képes lesz a következő generációs telekommunikációs eszközök kezelésére. Joe Armstrong, Robert Virding, és Mike Williams Bjarne Däcker felügyelete mellett végül megalkották az Erlang porgramozási nyelvet. Ugyan sok már meglévő nyelvet megvizsgáltak, és volt köztük néhány igen ígéretes jelölt, de egyik sem tartalmazta az összes olyan funkciót, ami elvárt volt. A nyelvre hatással volt az ML és Miranda funkcionális nyelvek, valamint olyan konkurens nyelvek, mint az ADA, Chill vagy a Module, illetve a Prolog logikai programozási nyelv. Az első Prolog alapú Erlang virtuális gép prototípus négy év alatt készült el. Végül az Ericsson 1998 decemberében a nyelvet nyílt forrásúvá tette, így bárki számára elérhető lett \cite{erlangBook}.

Az Erlang nyelv a nagy hibatűrő képességének, magas szintű konkurencia támogatásának köszönhetően kedvelt választás elosztott rendszerek fejlesztésében.


\subsection{TypeScirpt}

A TypeScript egy multi-paradigma programozási nyelv, ami lényegében a JavaScirpt nyelvet egészíti ki olyan szintaxis elmekkel, amik segítségével statikus típusozást tudunk elvégezni. TypeScriptben van lehetőségünk szerver- és kliensoldalon is programozni, a különböző keretrendszereknek köszönhetően. A TypeScript kódot futtatás előtt le kell fordítanunk. Itt a fordító elvégzi a szükséges szintaktikus és szemantikus elemzéseket, majd a típus definíciók és megszorítások eltávolítása után előáll a JavaScirpt forrás, amit már a megszokott JavaScript környezetekben futtathatunk \cite{webpageTS} \cite{wikipediaTS}.

Így egy fenntarthatóbb, könyebben kezelhető kódbázist kapunk, illetve a hibákat is előbb kitudjuk szúrni, ha megfelelő típusokat vezetünk be és használunk.

\subsection{Visual Studioc Code API}
A Visual Studio Code egy nyílt forráskódú editor (szekresztő), amit a Microsoft fejleszt és tart karban. A teljes szoftvert olyan elsősorban weben ismert nyelvekkel írták, mint TypeScript, JavaScript, HTML és CSS, ezzel is segítve azt, hogy a legtöbb platformon elérhető legyen \cite{wikipediaVSCODE}.

A fentieken kívül a szerkesztő program rendkívül gazdag fejlesztői dokumentációval és nagyon sok oldalú API-val, vagyis \textit{alkalmazásprogramozási felülettel (Application Programming Interface)} rendelkezik, ami a bővítmények fejlesztését lehetővé teszi. Az editor szinte minden funkcióját tudjunk vezérleni az API-ján keresztül, és ezt a fejlesztést is ez tette lehetővé.

\subsection{WebSocket}
A WebSocket egy számítógépes kommunikációs protokoll, ami teljes duplexitást, azaz kétirányú kommunikációt biztosít egyetlen TCP kapcsolat felett. A tehcnológiát 2011-ben szabványosították és azóta a \textit{Web Hypertext Application Technology Working Group} karbantartásában van, ami egy konzorcium a legnagyobb böngésző gyártokból (\textit{Microsoft, Google, Apple és Mozilla}). \cite{websocketWikipedia}

A portokoll segítségével a kliens és a szerver között mindkét irányban küldhetünk adatot, így nem szükséges a hagyományos kérés-válasz (\textit{request-response}) modellhez alkalmazkodni. Ilyen WebSocket alapú kommunikcáió van a Visualiser bővítmény és a RefactorErl között. 

\subsection{Remote Procedure Calls}
A Remote Procedure Call-nak (RPC), vagyis a távoli eljáráshívásnak a lényege az, hogy egy alkalmazás száméra meghívjon egy függvényt, ami egy távoli számítogépen van implementálva és végre hajtva, úgy mintha lokálisan, helyileg elérhető lenne. A fejlesztőnek megfelelően definiálnia kell a modult és a függvényt, amit végre kíván hajtani a távoli rendszeren, majd a távoli számítógép egy RPC alrendszere ezt a hívást futtatható kóddá alakítja és végrehajta a távoli hívást \cite{distributedSystems}.

A távoli eljáráshívás igen fontos szerepet játszik az elosztott rendszerekben. Az Erlangban egy \lstinline{rpc} modul segíti a fejlesztők munkáját, aminek a megfelelő felparaméterezésével elvégezhetjük a távoli hívást. Ilyen kapcsolatot alakítottam ki a RefactorErl és az Erlang LS node-jai között.



\section{Komponensek}

Az elkészült szoftver komponenseit négy fő részre lehet bontani: Erlang LS-beli illesztő modul, RefactorErl-beli illesztő modul, RefactorErl WebSocket komponense és a Visualiser kiegészítő. Ennek vizualizálásra tekintsük meg a \ref{fig:architecture} ábrát. Az ábrán fellelhető négy komponens nem teljese egészében feleltethető meg az előbb felsoroltakhoz.

A két RefactorErl-beli modult nem különböztettem meg az ábrán, hanem összevönt \textit{RefactorErl}-ként jellemeztem. Továbbá az Erlang LS kliensoldali forrásában nem történt változtatás a dolgozat keretein belül, azonban az architektúra megértése szempontjából fontosnak tartottam jelölni.

Az ábrán felsorolásra kerültek a használt kommunikációs protokollok is, amelyekről a \ref{usedTechnologies} részben olvashatunk bővebben.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\linewidth]{images/architecture.png}
  \caption{Komponensek viszonya egymáshóz}
  \label{fig:architecture}
\end{figure}

\subsection{Erlang LS-beli illesztő modul}
%\subsubsection{Bevezetés}
Az Erlang LS-ben egy meglehetősen miniális illesztő modul található, mely az üzleti logika jelentős részét a RefactorErlre bízza, hogy a projekt karbantartóinak minél kevesebb idegen kódot kelljen kezelniük. Az Erlang LS (vagy röviden: ELS) néhány helyen tartalmaz kiegészítéseket, most ezeket fogjuk sorra venni.

Az Erlang LS egy aktív projekt, akár havonta többször is jelenhet meg belőle újabb kiadás, ezárt a fejlesztés során a forrást a 21.2-es verziónál rögzítettem, és azt terjesztettem ki a szükgséges illesztő kódokkal

A kommunikáció alapját a \lstinline{els_refactorerl_diagnostics} modul adja, ami nagyban függ a \lstinline{els_refatorerl_utils} modultól. Vizsgáljuk meg közelebbről ezen modulokat.

\subsubsection{\lstinline{els_refactorerl_diagnostics} modul}

\textbf{Erlang Behavior:} Az Erlangban úgynevezett \textit{behaviour} segítségével tudunk álltalános kód részeket kiemelni. Amennyiben több modul is többnyire azonos funkcionalitásokat lát el úgy a generikus, közös részeket behaviourba érdemes kiemelni, a specifikus részt pedig a callback modulban (behaviour megvalósító, kiterjesztő modul) implementálni.

\textbf{Callback függvény:} Az Erlang callback függvénynek nevezünk egy olyan függvényt, aminek az implementálását a \textit{behavior} megköveteli.


Az \lstinline{els_refactorerl_diagnostics} modul az Erlang LS \lstinline{els_diagnostics} behavior-jét egészíti ki. 

A modul az alábbi típusokat definiálja:

\lstset{caption={Típusdefiníciók az \lstinline{els_refactorerl_diagnostics} modulban}, label=src:erlang}
\begin{lstlisting}[language={erlang}]
-type refactorerl_diagnostic_alias() :: atom().
-type refactorerl_diagnostic_result() :: {range(), string()}.
\end{lstlisting}



\begin{itemize}
    \item \lstinline{refactorerl_diagnostic_alias}: szinoníma az \lstinline{atom}-ra
    \item \lstinline{refactorerl_diagnostic_result}: egy pár, aminek első tagja egy \lstinline{range}, ami egy Erlang LS-beli típus, a második tagja pedig egy sztring (szöveges karakterlánc)
\end{itemize}

A modul az alábbi függvényeket definiálja:

\begin{itemize}
    \item \lstinline{-spec is_default() -> boolean().}
        \begin{itemize}
            \item \textbf{Bemenet}: -
            \item \textbf{Kimenet}: logikai típus, hamis
            \item \textbf{Leírás}: \textit{callback függvény}, azt mondja meg, hogy alapértelmezett konfigurációval a diagnosztika fusson-e. Esetünk ez hamis értéket fog visszadni.
        \end{itemize}
     
    \item \lstinline{-spec run(uri()) -> [els_diagnostics:diagnostic()].}
        \begin{itemize}
            \item \textbf{Bemenet}: Uniform Resource Identifier, avagy univerzális erőforrás aznosító, rövide URI. Esetünkben ez egy elérési útvonal lesz, ami az adott elemzendő fájlra mutat.
            \item \textbf{Kimenet}: ELS diagnosztikákat tartalmazó lista
            \item \textbf{Leírás}: \textit{callback függvény}, főbelépési pont a diagnosztikák tekintetében. A diagnosztikák RefactorErl elemzéseiből származik.
        \end{itemize}
    
    \item \lstinline{-spec source() -> binary().}  
        \begin{itemize}
            \item \textbf{Bemenet}: -
            \item \textbf{Kimenet}: A diagnosztika forrása: \textit{RefactorErl}
            \item \textbf{Leírás}:  \textit{callback függvény}, minden diagnosztikának kell lennie egy forrássának, ami a diagnosztika mellett megjelenik.\footnote{Ez sok esetben szokott \textit{Compiler} (azaz fordító) azonosítot tartalmazni, hiszen a fordítóból elég sok diagnosztika származhat. Esetünkben ez \textit{RefactorErl}, hiszen a diagnosztikákat az eszköz állítja elő.} Ez a függvény áthív a \lstinline{els_refactorerl_utils} modulba és onnan tudja meg ezt a konstans információt.\footnote{A későbbi fenntarthatőség és továbbfejlesztés jegyében történt ez a kialakítás}
        \end{itemize}
    
   
    \item \lstinline{-spec enabled_diagnostics() -> [refactorerl_diagnostic_alias()].} 
        \begin{itemize}
            \item \textbf{Bemenet}: -
            \item \textbf{Kimenet}: Az engedélyzett diagnosztika azonosítók listája
            \item \textbf{Leírás}:   A konfigurációs fájl alapján és az \lstinline{els_config} modul segítségével visszatér az engedélyezett 
        \end{itemize}
    
    
    \item \lstinline{-spec make_diagnostics([refactorerl_diagnostic_result()]) -> any().} 
        \begin{itemize}
            \item \textbf{Bemenet}: \lstinline{refactorerl_diagnostic_result}-ból álló lista
            \item \textbf{Kimenet}: ELS-beli \lstinline{diagnostic} típusú lista
            \item \textbf{Leírás}: konvertáló függvény amely átalakítja a input (bemenet) listát, úgy, hogy az ELS megtudja jeleníteni
        \end{itemize}
    \end{itemize}
    
    
\subsubsection{\lstinline{els_refactorerl_utils} modul}
A diagnosztikai modul nagyban támaszkodik a segéd moduljára, a \lstinline{els_refactorerl_utils}, most nézzük meg ezt a modult, hogy milyen függvényeket definiál:

\begin{itemize}
    \item \lstinline'-spec referl_node() -> {ok, atom()} | {error, ErrorReason}. '
        \begin{itemize}
            \item \textbf{Bemenet}: -
            \item \textbf{Kimenet}: 
            \begin{itemize}
                \item \lstinline|{ok, RefactorErlNode}|: a második tagja a párnak tartamazza azt a node-ot amin a RefactorErl fut. Ebben az esetben az RPC alapú kapcsolat a RefactorErl node-al létre jött, használható.
                \item \lstinline|{error, ErrorReason}|: amennyiben a RefactorErl node-al bármi gond van ilyen formában kapjuk a node-ot. Az \lstinline{ErrorReason} a hiba okát tartalmazza. Amennyiben \lstinline{disconnected} az azt jelenti, hogy nem sikerült kapcsolódni a RefactorErl-hez, azonban amint lesz rá lehetőség a rendszer újra fogja próbálni. Ammenyiben \lstinline{disabled} a hiba oka, úgy a node-al a kommunikáció közben valami hiba történt, ami hatására le lett tiltva. Ezt a letiltást csak az Erlang LS újraindításával lehet feloldani. Illetve lehet még \lstinline{other} amennyiben valami olyamsi hiba történt, amire nem készültünk fel korábban.
            \end{itemize}
            \item \textbf{Leírás}: Amikor megnyitunk egy újabb fájlt vagy módosítunk egyet a lemezen, akkor az ELS  lefuttatja (vagy újrafuttatja) a diagnosztikákat, s ekkor intézi az RPC hívást a RefactorErl node-ra. Ehhez ezt a függvényt használja. Amennyiben a kapcsolat még nem jött létre (és nem is lett rossznak ítélve), úgy újra probálkozik annak létrezhozásával.
        \end{itemize}
    
    
    
    \item \lstinline{-spec add(uri()) -> error | ok.}:  Amennyiben az \lstinline{ok} atommal tér vissza, úgy sikeres volt, amennyiben az 
    \lstinline{error} atommal, úgy sikertelen
    \begin{itemize}
            \item \textbf{Bemenet}: globális útvonal
            \item \textbf{Kimenet}: \lstinline{error} atom amennyiben a művelet nem volt sikeres, és \lstinline{ok} atom amennyiben sikeres volt.
            \item \textbf{Leírás}: hozzá adja a paraméterében kapott globális útvonalon elérhető fájlt a RefactorErl adatbázisához, RPC hívással
        \end{itemize}
    
    
    
    
    \item \lstinline{-spec run_diagnostics(list(), atom()) -> list().}:
    \begin{itemize}
            \item \textbf{Bemenet}:  első paraméterében adjuk meg azon diagnosztika azonosítóknak listáját amelyeket szeretnénk futtatni, a második paraméterben, pedig a modult, amire az eredmény halmazt szűkíteni kell
            \item \textbf{Kimenet}: még nyers formátumú diagnosztika
            \item \textbf{Leírás}: RPC hívással lefuttatja a kért diagnosztikákat a kért modulon a RefactorErl node-on
        \end{itemize}
    
    
    
    
    \item \lstinline{-spec notification(string(), number()) -> atom().} 
        \begin{itemize}
            \item \textbf{Bemenet}: Az egy paraméteres verzió esetében információs üzenetet küldhetünk, s magát az üzenet paraméterül adjuk meg. A két paraméteres verzióban a második paraméterrel pontosítani tudjuk azt, hogy milyen típusú üzenetet szeretnénk. Itt használhatjuk 1,2,3 vagy 4 értékekekt, vagy az erre a célra definiált makrókat:
            \begin{itemize}
                \item \lstinline{?MESSAGE_TYPE_ERROR}: hiba típusú értesítés, értéke: 1
                \item \lstinline{?MESSAGE_TYPE_WARNING}: figyelmeztetés típusú értesítés, értéke: 2
                \item \lstinline{?MESSAGE_TYPE_INFO}: információ típusú értesítés, értéke: 3
                \item \lstinline{?MESSAGE_TYPE_LOG}: napló típusú értesítés, értéke: 4
            \end{itemize}   
            \item \textbf{Kimenet}: 
            \item \textbf{Leírás}: egy segéd függvény amivel LSP protokoll feletti értesítéseket tudunk megjeleníteni. 
        \end{itemize}
    
    
    
    \item \lstinline{-spec is_refactorerl(atom()) -> boolean().} 
    \begin{itemize}
            \item \textbf{Bemenet}: Az Erlang node amin feltételezzük, hogy olyan verziójú RefactorErl node fut, ami képes az ELS kommunikálni
            \item \textbf{Kimenet}: igaz érték, amennyiben valóban megfelelő verziójú RefactorErl node fut, különben hamis.
            \item \textbf{Leírás}: A függvény egy RPC hívást intéz a RefactorErl node-jára. Megpróbálja meghívni az ott definiált \lstinline{referl_els:ping/0} függvényt. Amennyiben ez \lstinline|{refactorerl_els, pong}|-al tér vissza, úgy megfelelő verziójú RefactorErl-t futtat a node. Ha bármi mással, melynek oka lehet az, hogy nem megfelelő a verzió, vagy az is, hogy a node-on nem fut az eszköz.
        \end{itemize}
    
    
        
    \item \lstinline|-spec connect_node({validate |\lstinline{| retry, atom()}\lstinline|) -> {error, disconnected} | \lstinline{|} \lstinline| atom().}| 
    \begin{itemize}
            \item \textbf{Bemenet}: Az pár első tagjában a stratégiát határozzuk meg: \lstinline{validate} avagy \lstinline{retry}, a második pedig maga a node nevét adjuk meg
            \item \textbf{Kimenet}: \lstinline|{error, disconnected}|, ha nem jött létre kapcsolat, ha pedig igen, akkor \lstinline|{ok, Node}|, ahol a Node az Erlang node, amit megadtunk.
            \item \textbf{Leírás}: A stratégiát illetően \lstinline{validate} opció esetében a felhasználó tájékoztatva lesz a node állapotáról. Ha korábban már kapcsolat sikeresen felállt, akkor arról, ha pedig most ez nem sikerült akkor arról lesz tájékoztatva. \lstinline{retry} esetén a felhasználó csak akkor lesz tájékoztatva, ha a   
        \end{itemize}
    
    
    
    \item \lstinline{-spec source_name() -> binary().}
    \begin{itemize}
            \item \textbf{Bemenet}: - 
            \item \textbf{Kimenet}: \lstinline{<<"RefactorErl">>.}
            \item \textbf{Leírás}: A diagnosztika modul hívja meg ezt a függvényt. A későbbi bővíthetőség, fenntarthatőség jegyében lett ez ide kiemelve.
        \end{itemize}
    
    
    
    \item \lstinline|-spec variable_orgin(uri(), {number(), number()} ) -> error |\lstinline{| ok.} \lstinline|}|
    \begin{itemize}
            \item \textbf{Bemenet}: Első paraméter az útvonal binárosan, a második párban rendre sor és oszlop információ, az adott változóról.
            \item \textbf{Kimenet}: \lstinline{error}, ammenyiben valami hiba történt, \lstinline{ok} ammenyiben mindben rendben.
            \item \textbf{Leírás}: A RefactorErl node felé intézett RPC híváson keresztül kiszámolja egy változó Origin értékét.
        \end{itemize}
    
    
    
    \item \lstinline{-spec variable_reach(uri(), {number(), number()}) -> error | ok.}
    \begin{itemize}
            \item \textbf{Bemenet}: Első paraméter az útvonal binárosan, a második párban rendre sor és oszlop információ, az adott változóról.
            \item \textbf{Kimenet}: \lstinline{error}, ammenyiben valami hiba történt, \lstinline{ok} ammenyiben mindben rendben.
            \item \textbf{Leírás}: A RefactorErl node felé intézett RPC híváson keresztül kiszámolja egy változó Reach értékét, amit Web Socketen keresztül megküldd, a Visualiser bővítmény felé. 
        \end{itemize}
    
    
    
    \item \lstinline{-spec dependency_graph(string(), func | mod) -> error | ok.}
    \begin{itemize}
            \item \textbf{Bemenet}: Az első paraméter a függvény vagy modul nevét tartalmazza rendre \lstinline{<modul_neve>:<fuggveny_neve>/<aritas>}, illetve \lstinline{<module_neve>} formában.
            \item \textbf{Kimenet}: lstinline{error}, ammenyiben valami hiba történt, \lstinline{ok} ammenyiben mindben rendben.
            \item \textbf{Leírás}: A RefactorErl node felé intézett RPC híváson keresztül kiszámolja egy függvény vagy modul függőségi gráfját, amit Web Socketen keresztül megküldd, a Visualiser bővítmény felé.
        \end{itemize}
    
    
    
    \item \lstinline{-spec dyncall(module(), function(), arity()) -> error | ok.}
    \begin{itemize}
            \item \textbf{Bemenet}: Rendre modul neve, függvény neve és aritása.
            \item \textbf{Kimenet}:  lstinline{error}, ammenyiben valami hiba történt, \lstinline{ok} ammenyiben mindben rendben.
            \item \textbf{Leírás}: Kiszámolja RPC híváson a RefactorErl node-on egy függvénynek a hivatkozásait. Amennyiben a dinamikus analízis el lett végezve, úgy a dinamikus hívásokat is beleteszi.
        \end{itemize}

\end{itemize}




\subsubsection{\lstinline{els_diagnostics} modul módosítása}

A fent leírt kettő modul önmagabán még nem elég. Ahhoz, hogy lefussanak, úgy a \lstinline{els_diagnostics:available_diagnostics/0} függvényét is ki kell még egészíteni. Ez a függvény tartalmazza az elérhető diagnosztikák azonosítóit.

\lstset{caption={Elérhető diagnosztikák módosított verziója}, label=src:erlang}
\begin{lstlisting}[language={erlang}]
-spec available_diagnostics() -> [diagnostic_id()].
available_diagnostics() ->
  [ <<"bound_var_in_pattern">>
  , <<"compiler">>
  , <<"crossref">>
  , <<"dialyzer">>
  , <<"gradualizer">>
  , <<"elvis">>
  , <<"unused_includes">>
  , <<"unused_macros">>
  , <<"unused_record_fields">>
  , <<"refactorerl">>
  ].
 \end{lstlisting}
 
Minden egyes fent felsorolot azonosítóhoz tartozik egy modul, mely implementálj a logikát. A modul neve a következő képpen áll elő: \lstinline{els_<diagnosztika_azonosito>_diagnostics}.

\\

\subsubsection{\lstinline{els_config} modul módosítása}

Ezen kívül ahhoz, hogy a diagnosztikából olvassunk, az \lstinline{els_config} modulba is kellett kiegészítéseket tenni.

\begin{itemize}

    \item A modulban van egy típusdefiníció ami a lehetséges konfigurációs kulcsokat tartalmazza. Ehhez hozzáadtam egy újat: \lstinline{refactorerl}, így most már a bővített típus vázlata:
\lstset{caption={Konfigurációs kulcs, módosított típusdefiníció}, label=src:erlang}
\begin{lstlisting}[language={erlang}]
-type key()   :: apps_dirs
               | apps_paths
               | capabilities
               | diagnostics
               ...
               | refactorerl.
 \end{lstlisting}
 
     \item A modulban van egy másik típusdefiníció ami a konfiguráció állapotának tárolására lesz majd alkalmas. Ehhez hozzáadtam egy kulcsot: \lstinline{refactorerl}, amihez tartozó érték pár vagy a \lstinline{notconfigured} atom, vagy egy \textit{map} típus (kulcs-érték párokat tartalmazó szótár-szerű adatszerkezet, amely hatékony kulcs elérést tesz lehetővé). Ez látható az alábbi kódrészletben:
\lstset{caption={Módosított állapot típus}, label=src:erlang}
\begin{lstlisting}[language={erlang}]
-type state() :: 
#{ apps_dirs        => [path()]
 , apps_paths       => [path()]
 , lenses           => [els_code_lens:lens_id()]
 , diagnostics      => [els_diagnostics:diagnostic_id()]
 ...
 , refactorerl      => map() | 'notconfigured'
 }.
 \end{lstlisting}
 
 \item Következő lépésben megkell keresni a \lstinline{"refactorerl"} kulcsot a konfigurációs fájlban, majd annak értékét beállítani. Ez látható az alábbi kódrészletben:
\lstset{caption={Konfigurációs kulcsmegkeresése, majd beállítása}, label=src:erlang}
\begin{lstlisting}[language={erlang}]
...
RefactorErl = maps:get("refactorerl", Config, notconfigured),
...
ok = set(refactorerl, RefactorErl),
...
 \end{lstlisting}
    
\end{itemize}

Amennyiben a konfigurációs fájlban nem található lilyen kulcs, úgy abban az esetben  \lstinline{notconfigured} lesz beállítva. (Hiszen a \lstinline{maps:get/3} harmadik paramétere azt mondja meg, hogy mi legyen az érték, ha az adott szótárban nincsen olyan kulcs).

Ammeniyben pedig a kulcs sikeresen megtalálható a fájlban úgy, az ELS betölti azt, s rendelkezésnkre adja az eszközölt módosításoknak köszönhetően.

Így már az összes olyan hozzáadott, illetve módosított modult megnéztük, a következő részben a kódakciókat működtető modulokat fogjuk sorra venni. 


\subsubsection{Kódakciók: \lstinline{els_code_action_provider} modul }
A modulban található egy \lstinline{code_action/3} függvény. Ennek kiértékelése kapcsán állnak elő a lehetséges kódakciók. Ezt a függvényt úgy egészítettem ki, hogy az alapértelmezett ELS kódakciókhoz, hozzáfűzi a RefactorErl-nek szánt akciókat az alábbi módon:

\lstset{caption={\lstinline{code_action/3} kibővített verziója}, label=src:erlang}
\begin{lstlisting}[language={erlang}]
-spec code_actions(uri(), range(), code_action_context()) -> [map()].
code_actions(Uri, Range, Context) ->
  #{ <<"diagnostics">> := Diagnostics } = Context,
  Actions0 = [ make_code_action(Uri, D) || D <- Diagnostics],
  Actions = lists:flatten(Actions0),
  RefactorErlActions = referl_action(Uri, Range),
  Actions ++ RefactorErlActions.
\end{lstlisting}

\noindent A RefactorErl eszközhöz szánt kódakciókat a \lstinline{referl_action/2} készíti el. \\
\noindent \lstinline{-spec referl_action(uri(), range()) -> any().}
\begin{itemize}
    \item \textbf{Bemenet:} Az a fájl és tartomány, amire kódakciókat előszeretnénk állítani.
    \item \textbf{Kimenet:} Kódakciókat tartalmazó lista.
    \item \textbf{Leírás:} Ammenyiben a RefactorErl node validálva van, úgy meghívja a \lstinline{variable_action/2}, \lstinline{depgraph_action/2} és \lstinline{dyncall_action/2} függvényeket, hogy kiszámítsák a megfelelő kódakciókat. Amennyiben nincsen ilyen a RefactorErl node validálva, úgy üres listával tér vissza, hisz ez esetben nem akarunk megjeleníteni kódkaciót
\end{itemize}

\noindent \textbf{A kódakciókról}

Összességében a kódakció nem más mint egy szótár adatszerkezet, ami tartalmaz egy \lstinline{title}, \lstinline{kind} és \lstinline{command} kulcsot. A \lstinline{title} lényegében egy bináris szöveg, ami a kódakció szövege, címe lesz. A \lstinline{kind}, vagyis a típusát az LSP protokollban definiáltakból tudjuk megválasztani \footnote{\url{https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/\#codeActionKind}}. Itt a \lstinline{<<"refactor">>} opciót használtam. A \lstinline{command} esetében pedig a parancs létrehozásához \lstinline{els_command} modul \lstinline{make_command} függvényét használtam. Az alábbiakban látható erre egy példa.

\lstset{caption=Egy példa a kódakcióra, label=src:erlang}\label{codeActionExample}
\begin{lstlisting}[language={erlang}]
CodeAction = #{ title =>  Title
              , kind => <<"refactor">>
              , command => Command }.
\end{lstlisting}

\noindent \textbf{Segdéfüggvények}

\textbf{POI-k az Erlang LS-ben.} Az Erlang LS, a RefactorErlhez hasonlóan elemzi a forráskódot, s a szintaktikai elemeket egy POI struktúrba szervezi. Egy ilyen POI tartalmazza többek között az adott egység kiterjedését és típusát is. A kódakciók kapcsán a POI-k típusára támaszkodtam. Az általam használt típusok:
\begin{itemize}
    \item \lstinline{variable}, vagyis változó;
    \item \lstinline{application}, vagyis függvény alkalmazás, hívás;
    \item \lstinline{function_clause}, vagyis függvény definíciónak egy ága (amennyiben egyetlen ág van, úgy maga a függvény definíció);
    \item \lstinline{module}, vagyis modul. definíció.
    
\end{itemize}

%\begin{itemize}
%    \item 
\noindent \lstinline{-spec variable_action(uri(), range()) -> [map()].}
    \begin{itemize}
        \item \textbf{Bemenet:} Az a fájl és tartomány, amire kódakciókat előszeretnénk állítani.
        \item \textbf{Kimenet:} Kódakciókat tartalmazó lista
        \item \textbf{Leírás:} Az ELS reprezentációjából, kiválogatja változó típusú egységeket, majd a \lstinline{make_variable_action} segítségével elkészíti a rájuk illeszkedő kódakciót.
    \end{itemize}
    
    
    
%    \item 
\noindent \lstinline{-spec make_variable_action(uri(), range(), [poi()]) -> [map()].}
    \begin{itemize}
        \item \textbf{Bemenet:} Az a fájl és tartomány, és a hozzá kapcsolódó POI-k amire kódakciókat előszeretnénk állítani.
        \item \textbf{Kimenet:} Kódakciókat tartalmazó lista
        \item \textbf{Leírás:} Előállítja a kódakció szövegezését és a hozzátartozó parancs hivatkozást.
    \end{itemize}
    
    
    
%    \item 
\noindent  \lstinline{-spec depgraph_action(uri(), range()) -> [map()].}
    \begin{itemize}
        \item \textbf{Bemenet:} Az a fájl és tartomány, amire kódakciókat előszeretnénk állítani.
        \item \textbf{Kimenet:} Kódakciókat tartalmazó lista
        \item \textbf{Leírás:} Az ELS reprezentációjából, kiválogatja függvény hívás és a moduldefiníció típusú egységeket, majd a \lstinline{make_depgraph_action} segítségével elkészíti a rájuk illeszkedő kódakciót.
    \end{itemize}
    
    
    
%    \item 
\noindent  \lstinline{-spec make_depgraph_action(uri(), range(), [poi()]) -> [map()].}
    \begin{itemize}
        \item \textbf{Bemenet:} Az a fájl és tartomány, és a hozzá kapcsolódó POI-k amire kódakciókat előszeretnénk állítani.
        \item \textbf{Kimenet:} Kódakciókat tartalmazó lista
        \item \textbf{Leírás:} Előállítja a kódakció szövegezését és a hozzátartozó parancs hivatkozást.
    \end{itemize}
    
    
    
%    \item 
\noindent \lstinline{-spec dyncall_action(uri(), range()) -> [map()].}
    \begin{itemize}
        \item \textbf{Bemenet:} Az a fájl és tartomány, amire kódakciókat előszeretnénk állítani.
        \item \textbf{Kimenet:} Kódakciókat tartalmazó lista
        \item \textbf{Leírás:} Az ELS reprezentációjából, kiválogatja függvény hívás típusú egységeket, majd a \lstinline{make_dyncall_action} segítségével elkészíti a rájuk illeszkedő kódakciót.
    \end{itemize}
    
  %   \item 
\noindent   \lstinline{-spec make_dyncall_action(uri(), range(), [poi()]) -> [map()].}
    \begin{itemize}
        \item \textbf{Bemenet:} Az a fájl és tartomány, és a hozzá kapcsolódó POI-k amire kódakciókat előszeretnénk állítani.
        \item \textbf{Kimenet:} Kódakciókat tartalmazó lista
        \item \textbf{Leírás:} Előállítja a kódakció szövegezését és a hozzátartozó parancs hivatkozást.
    \end{itemize}
%\end{itemize}


\subsubsection{Kódakciók: \lstinline{els_execute_command_provider} modul }

Eddigiekben láthattuk azt, hogy maga a kódakció hogyan készül el. Egy ilyen kódakciónak része a parancs hivatkozás. Most pedig nézzük meg, hogyan lesz a parancs létrehozva. Egy parancs így épül fel:

\lstset{caption=Egy példa a parancsra, label=src:erlang}
\begin{lstlisting}[language={erlang}]
-type command() :: #{ title     := binary()
                    , command   := command_id()
                    , arguments => [any()]
                    }.
\end{lstlisting}

A parancsnak van címe (\lstinline{title}), azonosítója (\lstinline{command}) és argumentumai (\lstinline{arguments}). Az \lstinline{els_execute_command_provider} modulban az \lstinline{execute_command} függvény definícióját egészítettem ki új ágakkal.

Ezen új ágak:
\begin{itemize}
    \item \lstinline{execute_command(<<"refactorerl-variable-origin">>, Arguments)}
    \item \lstinline{execute_command(<<"refactorerl-variable-reach">>, Arguments)}
    \item \lstinline{execute_command(<<"refactorerl-dependency-graph">>, Arguments)}
    \item \lstinline{execute_command(<<"refactorerl-dyncall">>, Arguments)}
\end{itemize}

Ezen függvény ágak működése roppant egyszerű. Illesztenek a paraméterekre, majd meghívják a megfelelő \lstinline{els_refactorerl_utils} modulbeli függvényt.

Továbbá a modulban megtalálható egy \lstinline{options} nevű függvény, amiben ezen parancsokat regisztrálni kell.

\lstset{caption=\lstinline{els_execute_command_provider:options/0} kibővítése, label=src:erlang}
\begin{lstlisting}[language={erlang}]
-spec options() -> map().
options() ->
  #{ commands => [ els_command:with_prefix(<<"replace-lines">>)
                 , els_command:with_prefix(<<"server-info">>)
                 ...
                 , els_command:with_prefix(<<"refactorerl-variable-origin">>)
                 , els_command:with_prefix(<<"refactorerl-variable-reach">>)
                 , els_command:with_prefix(<<"refactorerl-dependency-graph">>)
                 , els_command:with_prefix(<<"refactorerl-dyncall">>)
                 ] }.
\end{lstlisting}

Az \lstinline{els_command:with_prefix} függvénye előállítja azt a parancsazonosítót mely előtagként tartalmazza egy a környzetre jellemző azonosítót.

\subsubsection{Kommunikáció a többi komponenssel}

Ezen modulok beépülnek, szerves részét képezik az Erlang LS-nek, így természetesen azzal a kapcsolat folyamatos. Ezen kívül a kommunikáció a RefactorErl node-jával RPC kapcsolaton keresztül történik. 

\subsection{RefactorErl-beli LS modul}
\subsubsection{Bevezetés}
\subsubsection{Modul felépítés}

\noindent A modul az alábbi típust definiálja: 
 
\lstset{caption=\lstinline{referl_els} modulbeli típusdefiníció, label=src:erlang}
\begin{lstlisting}[language={erlang}]
-type refactorerl_diagnostic_description() :: {string(), string()}.
\end{lstlisting}
 





\begin{itemize}
    \item \lstinline|-spec refactorerl_diagnostics() -> #{ string() => refactorerl_diagnostic_description() }.|
    \begin{itemize}
        \item \textbf{Bemenet:} -
        \item \textbf{Kimenet:} diagnosztika azonosítók listája
        \item \textbf{Leírás:} visszaadja az elérhető, definiált diagnosztika azonosítók listáját
    \end{itemize}
    
    
    
    \item \lstinline{-spec add(string()) -> error | ok.}
    \begin{itemize}
        \item \textbf{Bemenet:} A hozzáadni kívánt fájl elérési útvonala.
        \item \textbf{Kimenet:} \lstinline{error} vagy \lstinline{ok} az eljárás sikerességétől függően
        \item \textbf{Leírás:} A \lstinline{reflib_ui_router}-en keresztül hozzáad adja az adott fájlt a megadott útvonalon keresztül. A hozzáadás sikerességéről üzenetben kapunk visszajelzést, ennek megfelelően lehet a visszatérése \lstinline{error}, amennyiben valami hiba lépett fel a folyamat közben, \lstinline{ok}, amennyiben sikeres volt a folyamat
    \end{itemize}
    
    
    
    \item \lstinline{-spec run_diagnostic([atom()], module()) -> [referl_els_utils:common_diagnostic()].}
    \begin{itemize}
        \item \textbf{Bemenet:} A diagnosztika azonosítók listája, illetve a modul neve amire futtatni szeretnénk.
        \item \textbf{Kimenet:} Egy köztes diagnosztika leíró lista az Erlang LS és a RefactorErl között.
        \item \textbf{Leírás:} A megadott diagnosztika azonosítóból megkeresi a megfelelő diagnosztika leírót, mely alapján a \lstinline{make_query/2} segédfüggvénnyel elkészíti a lekérdezést. (A segédfüggvénynek még szükséges átadni a modult is amire futtatni szeretnénk) Követekező lépésben a \lstinline{referl_els_utils:query/1} segítségével a lekérdezést lefuttatja, majd a \lstinline{make_diagnostic/2} segítségével előállítja a köztes diagnosztika leírók listáját. Ennek a függvénynek szükséges a \textit{fejléc nélküli} eredmény, melyet a \lstinline{remove_headers} segítségével távolítunk el, illetve az üzenet, amit a diagnosztikával megakarunk jeleníteni.
    \end{itemize}
    
    
    
    \item \lstinline|-spec ping() -> {refactorerl_els, pong}.|
    \begin{itemize}
        \item \textbf{Bemenet:} -
        \item \textbf{Kimenet:} \lstinline|{refactorerl_els, pong}|
        \item \textbf{Leírás:} Arra használatos, hogy egy külső komponens RPC híváson keresztül ellenőrizni tudja, hogy az adott node-on megfelelő RefactorErl fut-e. 
    \end{itemize}
    
    
    \item \lstinline{-spec variable_origin(string(), {number(), number()}) -> ok | error.}
    \begin{itemize}
        \item \textbf{Bemenet:} Elérési útvonal és sor, oszlop páros az adott változó pozíciójának meghatározásához
        \item \textbf{Kimenet:} \lstinline{error} vagy \lstinline{ok} az eljárás sikerességétől függően
        \item \textbf{Leírás:} Az \lstinline{execute_query/5} segítségével kiszámolja a változó Origin értékét és Web Socketen keresztül megküldi a Visualisernek.
    \end{itemize}
    
    
    \item \lstinline|-spec variable_reach(string(), {number(), number()})| \lstinline{ -> ok | error.}
    \begin{itemize}
        \item \textbf{Bemenet:} Elérési útvonal és sor, oszlop páros az adott változó pozíciójának meghatározásához
        \item \textbf{Kimenet:} \lstinline{error} vagy \lstinline{ok} az eljárás sikerességétől függően
        \item \textbf{Leírás:} Az \lstinline{execute_query/5} segítségével kiszámolja a változó Reach értékét és Web Socketen keresztül megküldi a Visualisernek.
    \end{itemize}
    \item \lstinline|-spec execute_query(string(), {number(), number()}, string(), atom(), string())| \lstinline{ -> ok | error.}
    \begin{itemize}
        \item \textbf{Bemenet:}
        \begin{enumerate}
            \item Útvonal
            \item Sor, oszlop páros a pozícióhoz
            \item Lekérdezés (\textit{query})
            \item Küldési azonosító: ezzel az azonosítóval lesz elküldve az eredmény a Visualiser felé
            \item Lebegő információ: ez az információ lesz megjelenítve a Visualiserben, amikor a felhasználó a kurzorát a kijelölés fölé viszi.
        \end{enumerate}
        \item \textbf{Kimenet:} \lstinline{error} vagy \lstinline{ok} az eljárás sikerességétől függően
        \item \textbf{Leírás:} A pozició skalárissá alakítása után a \lstinline{refusr_sq:run/3} segítségével lefuttatja a lekérdezést, majd becsomagolja becsomagolja egy a \ref{structQueryRes} forrás részleten is látható objektumba, majd elküldi a \lstinline{referl_vsc_websocket:send2}  -vel
    \end{itemize}
    


    \item \lstinline{-spec dynamic_calls(string(), string(), string()) -> ok | error.}
    \begin{itemize}
        \item \textbf{Bemenet:} rendre modul, illetve függvény neve, majd aritása
        \item \textbf{Kimenet:} \lstinline{error} vagy \lstinline{ok} az eljárás sikerességétől függően
        \item \textbf{Leírás:} Előállítja a lekérdezést, majd \lstinline{refusr_sq:run/3} segítségével lefuttatja, majd becsomagolja becsomagolja egy a \ref{structQueryRes} forrás részleten is látható objektumba, majd elküldi a \lstinline{referl_vsc_websocket:send2} -vel. \\
        A lekérdezés az alábbi szerkezetű \\ 
        \lstinline{"mods[name=<modul_neve>].funs[name=<fuggveny_neve> and arity=<aritasa>].refs"}
    \end{itemize}
    
    
    \item \lstinline{-spec dependency_graph(string(), func | mod) -> ok | error.}
    \begin{itemize}
        \item \textbf{Bemenet:} függvény vagy modul neve, illetve típusa. \lstinline{func} amennyiben függvényre végezzük a lekérdezést, \lstinline{mod} amennyiben modulra.
        \item \textbf{Kimenet:} \lstinline{error} vagy \lstinline{ok} az eljárás sikerességétől függően
        \item \textbf{Leírás:} Elküldi a Web Socketen keresztül a \ref{structOptionsForWs} részletben látható csomagolással a futtatáshoz szükséges paraméterek a Visualisernek, majd annak a feladata lesz lefuttatni. \\
\lstset{caption=Web Socketen keresztül küldött opciók, label=src:erlang}  \label{structOptionsForWs}
\begin{lstlisting}[language={erlang}] 
OptionsForWS = {struct, [
    {"level", "func" | "mod"},
    {"type", "all"},
    {"starting_nodes", [lists:flatten(Name)]},
    {"exclude_otp", false},
    {"exclude", ""},
    {"exclude_lib", ""},
    {"connection", ""},
    {"output_type", ""}
]}
\end{lstlisting}
    \end{itemize}
    
   
\end{itemize}





\subsubsection{Kommunikáció a többi komponenssel}

A RefactorErl-ben elhelyezett LS interfész modul főképpen az Erlang LS-el kommunikál, azonban hív olyan eljárásokat, amik Web Socketen keresztül a Visualiser komponenssel is kommunikál, így összességében mindkét komponenssel kommunikál.

Gondoljunk csak a diagnosztikákra: ebben az esetben kizárólagosan az ELS-el kommunikál, míg kódakciók esetében mind az Eralng LS, mind a Visualiser komponenssel kommunikál.



\subsection{RefactorErl-beli WebSocket komponens}

\subsubsection{Bevezetés}
A következő részekben azon modulokat fogjuk megtekinteni, ami a Web Socketen keresztüli a kommunikációért felelős, legyen szó kérdés-válasz alapú vagy közlés, küldés alapú kommunikációról.

\subsubsection{Adatszerkezetek}
A Web Socketen keresztül bináris formában tudunk adatot küldeni. A könnyű használhatóság érdekében JSON (JavaScipt Object Notion) objektumokat fogunk átküldeni, hiszen ezt a formátumot a TypeScript natívan támogtja, az Erlang pedig a Yaws \lstinline{json2} modulja segítségével használható. Természetesen először szérializálni kell, majd binárissá alakítani.

Legyakrabban JSON szótárakat vagy listákat fogunk átküldeni. A \lstinline{json2:encode/1} függvény az Erlang listákat egyértelműen áttudja alakítani JSON listává, sajnos a szótárak esetében kissé át kell alakítanunk az adatszerkezetünk.

\lstset{caption=Példa szótárak átalakítása, label=src:erlang} \label{mapConvertJson}
\begin{lstlisting}[language={erlang}] 
Struct = {struct, [
            {"key", "value"}, 
            {"key2", ["alpha", "beta"]}
        ]},
Json = json2:encode(Struct),
...
\end{lstlisting}

\lstset{caption=Átalakított példa szótár, label=src:erlang} \label{mapConvertJsonResult}
\begin{lstlisting}[language={erlang}] 
{
    "key": "value",
    "key2": ["alpha","beta"]
}
\end{lstlisting}

Amint a fenti \ref{mapConvertJson} kódrészleten látszodik, ahogyan az adatszerkezetünket szervezni kell, hogy a \ref{mapConvertJsonResult} forrásban lévő eredményt kapjuk. Ez alapján látszik, hogy egy olyan párban kell rendezni, melynek első komponense a \lstinline{struct} atom, a második pedig kulcs-érték párok listája.


\lstset{caption=Egy lekérdezés egyetlen elemének reprezentációja, label=src:erlang} \label{structQueryRes}
\begin{lstlisting}[language={erlang}]
{struct, [
            {"fromPosLn", FromPosL},    % kezdo sor
            {"fromPosCol", FromPosC},   % kezdo oszlop
            {"toPosLn", ToPosL},        % vege sor
            {"toPosCol", ToPosC},       % vege oszlop
            {"name", Name},             % nev infomacio
            {"hoverInfo", HoverInfo},   % lebego informacio
            {"file", File},             % fajl
            {"noPos", false | true}     % tartalmaz-e poziciót?
        ]}
\end{lstlisting}



\subsubsection{\lstinline{referl_vsc} modul}

\noindent \textbf{Néhány fogalom}

\\
\vspace{14pt}

\noindent \textbf{Property} az Erlangban egy propertynek nevezünk egy olyan adatszerkezetet  ami vagy önmagában egy atom vagy kulcs érték pár. Kulcsként legtöbbször atomot választunk, bár ez inkább csak konveció (szokás).

\\
\vspace{14pt}


\noindent \textbf{Property lista} egy olyan lista melynek elemei \textit{property-k}. Gyakran emlegetjük röviden \textbf{proplist}-nek.

\\
\vspace{14pt}

Ez a modul felelős a Yaws webszerver beágyazott módban való elindításáért és felkonfigurálásáért. \cite{zacharyYawsBook}
A modul jelentős részében a \lstinline{referl_web2} modulra épül. Két interfész függvénye van:

\begin{itemize}
    \item \lstinline{start()} vagy \lstinline{start(Props)}: Elindítja az alapértelmezett paraméterekkel a Yaws webszervert. Ezen paramétereket lehet módosítani, amennyiben paraméterül adunk egy property listát.
    \item \lstinline{stop()}: Leállítja a VSC (Visual Studio Code) Visualiser applikációt, és a Yaws webszervert.
\end{itemize}
 
Ez a modul elindítja és leállítja a VSC alkalmazást. Az indításhoz megadható főbb paraméterek:

\begin{itemize}
    \item \lstinline{yaws_port}: A port, amin keresztül Web Socket kommunikálni fog. Ez alapértelmezetten \lstinline{8002} és a Visualiser bővítmény csak ezen a porton képes kommunikálni
    \item \lstinline{yaws_listen}: Az IP\footnote{Internet Protocoll} cím, amin keresztül Web Socket kommunikálni fog. Ez alapértelmezetten \lstinline{127.0.0.1} és a Visualiser bővítmény csak ezen a címen képes kommunikálni
    \item \lstinline{yaws_path}: Az a útvonal, ahonnan a Yaws webszervert indítani szeretnénk. 

\end{itemize}

\subsubsection{\lstinline{referl_vsc_sup} modul}

Egy egyszerű felügyelő (\textit{supervisor}) modul, ami újraindít egy gyerek folyamatot, ha azzal bármi baj történik. Ez az úgy nevezett \textit{One for One} (\lstinline{one_for_one}) stratégia. 

\subsubsection{\lstinline{referl_vsc_session} modul}

Egy generikus szerver (\lstinline{genserver}) modul, ami az aktív Web Socketek tárolásért 
felelős. A publikus interfésze lényegébe három fő feladatot lát el: socketetk lekérését, hozzáadását, illetve eltávolítását. Nézzük meg ezeket sorban:

\begin{itemize}
    \item \lstinline{get_websockets/0}: visszaadja az aktívnak vélt socketek azonosítóját.\footnote{Socket a listából csak akkor kerül ki, ha egy küldés művelet nem zárult sikerrel, így elképzelhető, hogy még egyszer küldünk zárt vagy hibás socket-re, de többször nem}
    \item \lstinline{add_websocket/1}: paraméterként adott Socket azonosítót eltárolja
    \item \lstinline{remove_websocket/1}: paraméterként adott Socket azonosítót eltávolítja
\end{itemize}



\subsubsection{\lstinline{referl_vsc_websocket} modul}

Ez a modul felelős a Web Socketen keresztül történő kommunikációért. A publikus interfésze nem kifejezetten bonyolult, azonban a kérések lekezelésére igen sok belső függvény áll rendelkezésre. Nézzük meg először a publikus interfészt:

\noindent \lstinline{handle_open(WSState, State)} \\
\noindent Egy Yaws Callback függvény. Akkor kerül meghívásra, amikor egy új Web Socket akar kapcsolódni. A \lstinline{WSState} tartalmazza a Web Socket azonosítóját, ezt eltároljuk későbbre, amikor közlés alapú küldést szeretnénk végrahajtni (például, mert ELS-ből jött a kérés).

\\
\vspace{14pt}
\noindent \textbf{Publikus interfész}
\\

\noindent \lstinline{handle_message(Message, State)} \\
\noindent Egy Yaws Callback függvény. Akkor kerül meghívásra, amikor egy üzenet érkezik egy Socket felől. A \lstinline{Message} paraméter három kategóriába sorolható, s így a működése is:
\begin{itemize}
    \item \lstinline|{text, <<"client-connected">>}|: egy a klienstől jövő megerősítés a kapcsolat felől
    \item \lstinline|{text, Binary}|: kérések erre az ágra fognak futni, a \lstinline{monitor_handle_request/2} segítségével kezeli le az ide érkező kéréseket
    \item \lstinline|{close, _Status, _Reason}|: Socket lezárásakor érkező kérés.
\end{itemize}
Ez a függvény a végre hajtást a \lstinline{monitor_handle_request/2} segédfüggvény segítségével hajtja végre. Ezt a függvényt fogja elindítani egy külön folyamaton egy ún. Erlang monitor alatt. Ennek a hasznossága az, hogy ha bármi probléma történik a végrehajtás közben, az könyebben lekezelhető, s az összeomlás megakadályozható.
\\


\noindent \lstinline{-spec send(list(), term()) -> error | ok.}\\
\noindent Az első paraméteréül adott eseménytípusra közléssel elküldi, avagy \textit{broadcast}-olja a második paraméteréül adott adatot az összes kapcsolódott Web Socket felé.\\

\noindent \lstinline{-spec broadcast_error(string()) -> error | ok.}\\
\noindent A paraméteréül adott, szöveget az összes kapcsolódott Web Socket felé továbbítja az \lstinline{error} esemény azonosítóval.\\

\noindent \lstinline{-spec broadcast_info(string()) -> error | ok.}\\
\noindent A paraméteréül adott, szöveget az összes kapcsolódott Web Socket felé továbbítja az \lstinline{info} esemény azonosítóval.\\

\\
\vspace{14pt}
\noindent \textbf{Definiált típusok}
\\
\noindent A modul egyetlen szinonímát definiál:
\noindent \lstinline{-type jsonlike() :: term().}


\\
\vspace{14pt}
\noindent \textbf{Belső működése}
\\


\noindent \lstinline{handle_request(Request)}
\begin{itemize}
    \item \textbf{Bemenet:} egy lekérdezés leíró
    \item \textbf{Kimenet:} Yaws válaszobjektum
    \item \textbf{Leírás:} Ez a függvény kezeli le a kéréseket a megfelelő belső függvények hívásával. Vegyük sorra a lehetséges lekérdezés típusokat (\lstinline{requestType}) és a hozzájuk tartozó működést:
    \begin{itemize}
        \item \lstinline{customQueryRequest}: egyedi lekérdezés, meghívja a \lstinline{custom_query_req/1}-t
        
        \item \lstinline{dependencyGraph}: függőségi gráf lekérdezés, meghívja a \lstinline{execute_graph_request/1}-t
        
        \item \lstinline{alive}  egy egyszerű lekérdezés a kliens felől, hogy ellenőrizze a kapcsolat épségét. Egyszerűen \lstinline{"alive"}-t ad válaszul
        
        \item \lstinline{databaseSync}: adatbázis szinkronizációt végez a RefactorErl-n, meghívja \lstinline|execute_simple_ui_request(synchronize)|-t, ami a \lstinline{reflib_ui_router} modulon keresztül elvégi ezt.
        
        \item \lstinline{dynamicAnal}: dinamikus függvényhívás elemzést végez a RefactorErl-n, meghívja \lstinline|execute_simple_ui_request(analy_dyn)|-t, ami \lstinline{reflib_ui_router} modulon keresztül elvégi ezt.
        
        \item \lstinline{dynamicClear}: dinamikus függvényhívás elemzésének eredményét törli a RefactorErl-n, meghívja \lstinline|execute_simple_ui_request(clean_dyn)|-t, ami \lstinline{reflib_ui_router} modulon keresztül elvégi ezt.
        
        \item Amennyiben olyan lekérdezés érkezett, ami nem tartalmaz típus azonosítót vagy olyat tartalmaz, amit nem ismerünk, úgy ezt hibakét jelezzük.
        
    \end{itemize}
\end{itemize} \\



\noindent \lstinline{-spec create_broadcast_event(list(), term()) -> {text, jsonlike()} \lstinline|}.}|
\begin{itemize}
    \item \textbf{Bemenet:} Első paraméter egy esemény azanosító, a második pedig egy olyan adat, amit a \lstinline{json2:encode} függvénye JSON szöveggé tud alakítani
    \item \textbf{Kimenet:} Egy olyan pár, melynek első tagja a \lstinline{text} atom, illetve a második tagja pedig egy JSON szerű szöveg. 
    \item \textbf{Leírás:} A megadott esemény azonosítóval előállítja azt az adatszerkezetet, amivel az adatot áttudjuk küldeni. Ez lesz a pár második tagja. ez az adatszerkezet valahogy így néz ki:
\lstset{caption=Esemény alapú küldés szerkezete, label=src:erlang} \label{structQueryRes2}
\begin{lstlisting}[language={erlang}]
{struct, [
    {"event", Event},       % esemeny azonosito
    {"data", Data},         % adat
]}
\end{lstlisting}
\end{itemize} \\

\noindent \lstinline{-spec create_callback_event(undefined | string(), term()) -> ok | error | {text, jsonlike()} \lstinline|}.}|
\begin{itemize}
    \item \textbf{Bemenet:} Első paraméter egy visszaküldési azanosító, a második pedig egy olyan adat, amit a \lstinline{json2:encode} függvénye JSON szöveggé tud alakítani. \lstinline{undefined} is megengedett.
    \item \textbf{Kimenet:} egy olyan pár, melynek első tagja a \lstinline{text} atom, illetve a második tagja pedig egy JSON szerű szöveg, vagy maga az \lstinline{ok} vagy \lstinline{error} atomok
    \item \textbf{Leírás:} Amennyiben a bemenetnél \lstinline{undefined} értéket kapunk, úgy nem, lehet visszaküldési azonosítóval elküldeni, ekkor a hibát szétküldjük az ismert Socketeknek. Ha ez sikerrel zárult, akkor \lstinline{ok} atom, ha nem akkor \lstinline{error} atomot kapunk vissza. \\ \\ Ha visszaküldési azonosítót kapunk, akkor előállítja azt az adatszerkezetet amivel az adatot áttudjuk küldeni. Ez lesz a pár második tagja, míg az első a \lstinline{text} atom lesz. Ez az adatszerkezet valahogy így néz ki:

\lstset{caption=Visszaküldési azonosítós küldés szerkezete, label=src:erlang} \label{structQueryRes3}
\begin{lstlisting}[language={erlang}]
{struct, [
    {"callbackId", Event},      % visszakuldesi azonosito
    {"data", Data},             % adat
]}
\end{lstlisting}
\end{itemize} \\

\noindent \lstinline{-spec get(list(), term()) -> term().}
\begin{itemize}
    \item \textbf{Bemenet:} első paramétere egy kulcs, a második egy lekérdezés leíró
    \item \textbf{Kimenet:} bármilyen Erlang term, ami a kulcs alatt van
    \item \textbf{Leírás:} A megadott kulcson található értéket visszadaja a lekérdezés leíróból. Amennyiben a kulcs nincs jelen úgy, \lstinline{undefined}-ot ad vissza.\\ \\ Egy lekérdezés leíró lényegében egy kulcs érték pároból álló lista, ami Web Socketen kersztül érkezik.
\end{itemize} \\

\noindent \lstinline{-spec cbId(term()) -> term().}
\begin{itemize}
    \item \textbf{Bemenet:} Egy lekérdezés leíró
    \item \textbf{Kimenet:} A visszaküldési azonosító, amennyiben a lekérdezés leíróban jelen van. Ha nincs jelen, akkor \lstinline{undefined}
    \item \textbf{Leírás:} Egyszerű kis segédfüggvény, ami visszadja a visszaküldési azonosítót ha jelen van a \lstinline{get/2} segítségével.
\end{itemize} \\

\noindent \lstinline{-spec dot_to_svg(string()) -> {ok, string()} | file_notexists | error | timeout.}
\begin{itemize}
    \item \textbf{Bemenet:} Egy elérési útvonal, ahol a DOT file található
    \item \textbf{Kimenet:} 
    \begin{itemize}
        \item \lstinline|{ok, string()}|: amennyiben sikerrel zárult a művelet, akkor a pár második komponensében lesz az SVG fájl elérési útvonala
        \item \lstinline|file_notexists|: amennyiben a megadott fájl nem létezik
        \item \lstinline|error|: az eljárás közben hibatörtént
    \end{itemize}
    \item \textbf{Leírás:} Az \lstinline{erlang:open_port/2} segítségével egy rendszerhíváson keresztül átalakítja a DOT fájlt SVG fájllá.
\end{itemize} \\


\noindent \lstinline{-spec construct_path(list()) -> list().}
\begin{itemize}
    \item \textbf{Bemenet:} egy fájlnév
    \item \textbf{Kimenet:} egy útvonal
    \item \textbf{Leírás:} a megadott fájlnévhez előállítja az adatkönyvtárbeli útvonalat.
\end{itemize} \\


\noindent \lstinline{custom_query_req(Request)}
\begin{itemize}
    \item \textbf{Bemenet:} egy lekérdezés leíró
    \item \textbf{Kimenet:} egy válasz objektum, amit a Yaws webszerver küld vissza
    \item \textbf{Leírás:} A megadott lekérdezést végrehajtja, majd az eredményt olyan formátumra hozza, hogy a Visualiser komponens könnyen megtudja jeleníteni, illetve csak a szükséges információkat tartalmazza. Az átalakításhoz használt segédfüggvények:
    \begin{itemize}
        \item \lstinline{construct_position_response/8}: lényegében egy pozíciós választ állít elő, ami a \ref{structQueryRes} forrásban mutatott szerkezettel megegyezik
        
        \item \lstinline{position_convert/2}: egy RefactorErl pozíció válaszból és egy lebegő információból a \lstinline{construct_position_response/8} meghívásával pozíciós választ állít elő
        
        \item \lstinline{construct_poslist_response/3}: egy RefactorErl pozíció válasz listából és egy lebegő információból, illetve egy fájl névből a \lstinline{position_convert/2} meghívásával pozíció listás választ állít elő, melynek szerkezete: (lásd \ref{poslistResp} forrás)
        
\lstset{caption=Pozíció listás válasz, label=src:erlang} \label{poslistResp}
\begin{lstlisting}[language={erlang}]
 {struct, [
    {"file", File},         % fajl
    {"items", PosList }.    % pozicio lista
]}.
\end{lstlisting}

    \item \lstinline{construct_eq_response/3}: egy RefactorErl pozíció mentes válasz listából és egy lebegő információból, illetve egy fájl névből a \lstinline{construct_position_response/8} meghívásával pozíció mentes listás választ állít elő, mely esetlben a sor, oszlop információk 0 értéket tartlamzanak, illetve \lstinline{noPos} kulcs alatt igaz érték fog szereplni.
        
        
\end{itemize} \\
    \end{itemize}
    
    
\end{itemize} \\


\noindent \lstinline{-spec get_graph_options(list()) -> list().}
\begin{itemize}
    \item \textbf{Bemenet:} egy \textit{proplist} ami Web Socketen keresztül érkezett és a kulcsai lehetnek: \lstinline{"type", "level", "starting_nodes", "exclude_otp", "exclude", "exclude_lib", "connection", "output_type"}. ezek hasonlóak, mint ahogy Shell-ből paramétereznénk a gráf lekérdezést. \cite{referlWikiDependency}
    \item \textbf{Kimenet:} Egy olyan property lista, ami átadható a gráf lekérdezésnek.
    \item \textbf{Leírás:} A szükséges ellenőrzések és átalakítások után a Web Socketen keresztül érkezett adatszerkezetből a RefactorErl függőségi gráf készítőjének átadható listát állít elő.
\end{itemize} \\



\noindent \lstinline{-spec request_class(list()) -> simple | construct | unknow.}
\begin{itemize}
    \item \textbf{Bemenet:} egy szöveg, ami a lekérdezés típusát tartalmazza
    \item \textbf{Kimenet:} a lekérdezés osztálya, ami lehet \lstinline{simple}, \lstinline{construct} vagy ismeretlen (\lstinline{unknow})
    \item \textbf{Leírás:} egy lekérdezés azonosító alapján megmondja, hogy mely kategóriába sorolható.
    \\ \lstinline{simple} kategória: \lstinline{"databaseSync", "dynamicAnal", "dynamicClear"}
    \\ \lstinline{construct} kategória: \lstinline{"customQueryRequest", "dependencyGraph"}
    \\ \lstinline{unknow} kategória: minden más
\end{itemize} \\


\noindent \lstinline{execute_graph_request(Request)}
\begin{itemize}
    \item \textbf{Bemenet:} egy lekérdezés leíró
    \item \textbf{Kimenet:} Yaws válasz objektum
    \item \textbf{Leírás:} a megadott lekérdezés leíróban található  gráf lekérdezést végrehajtja és a szükséges adatokat visszaküldi. Amennyiben a gráf szöveges ábrázolású, úgy a teljes gráfót átküldi, míg SVG reprezentáció kérése esetén csupán a fájl elérését. Az utóbbi esetben használja a \lstinline{construct_dot_response/1} segédfüggvényt, amely a DOT fájllá alakítás sikerességétől függően előállítja a válasz vagy hibaobjektumot.
\end{itemize} \\


\noindent \lstinline{error_reply(Request)}
\begin{itemize}
    \item \textbf{Bemenet:} egy lekérdezés leíró
    \item \textbf{Kimenet:} Yaws válasz objektum
    \item \textbf{Leírás:} a \lstinline{request_class/1} alapján a megfelelő formátumú hibát fogja küldeni. Ez végső esetben használatos, amikor nem teljesen nyílván való a hiba oka.
\end{itemize} \\




\subsubsection{Kommunikáció a többi komponenssel}

Ez a komponens a RefactorErl szerves részét képzi, így azzal nyílvánvaló módon kommunikál, továbbá Web Socketen keresztül a Visualiser komponenssel.


\subsection{RefactorErl Visualiser kiegészítő}

Mivel az Language Server Protocoll kissé limitált a megjelenítő eszközök tekintetében, ezért nem lehetett minden tervezett RefactorErl funkcionalitást használható módon integrálni az Erlang LS-be. Ezen hiányosság áthidalása érdekében született meg a Visualiser kiegészítő.

\subsubsection{Áttekintés}

\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{images/visualiser_arch.png}
  \caption{Visualiser alkomponenseinek viszonya egymáshóz}
  \label{fig:visualiserArch}
\end{figure}

A Visualiser is több alkomponensre bontható fel, mely a \ref{fig:visualiserArch} ábrán látható. Vegyük ezeket sorra, és tekintsük meg működésüket.

\subsubsection{\lstinline{extension.ts}}

Ez fő belépési pontja a kiegészítőnek, mindösszesen egyetlen függvénye van: az \lstinline{activate}, ami paraméteréül a Visual Studio Code kontextusát kapja, majd elkezdi aktíválni a bővítményt a következő lépésekkel:

\begin{enumerate}
    \item Példányosítja a beépített (\lstinline{BuiltInQViewProvider}) és a egyéni lekérdezések (\lstinline{CustomQueryProvider}) megjelenítőit és regisztrálja a szerkesztő számára
    \item Párosítja a Web Socket felől érkező eseményeket a megfelelő eseménykezelőkkel
    \item A Web View-t vagyis a \lstinline{DependencyGraphView}-t is inicializálja
    \item A szükséges parancsokat a \lstinline{RefactorErlCommands} segítségével beállítja
    \item Az egyedi lekérdezésekhez szükséges dialógust inicializálja
\end{enumerate}

\subsubsection{\lstinline{RefactorErlCommands} osztály}

Lényegében egyetlen osztályszintű függvént tartalmaz: \lstinline{setCommandForContext}, aminek paraméteréül a szerkesztő kontextusát kell megadnunk, majd ehhez a kontextushoz beállítja az alábbi parancsokat:

\begin{itemize}
    \item \lstinline{builtinView.goToLocation} és \lstinline{customQuery.goToLocation}: arra használatos, hogy egy \lstinline{RangeDescriptorral} megadott pozícióra ugorjunk
    
    \item \lstinline{customQuery.noPosNotify} ammenyiben nem áll rendelkezésre pozíció ezen parancs segítségével adunk erről a felhasználónak értesítést
    
    \item \lstinline{refactorErl.checkConnection}: ezen parancs segítségével tudjuk a Vezérlőpult (\textit{Dashboard}) felületéről a kapcsolatot ellenőrizni
    
    \item \lstinline{refactorErl.tryAgainConnect}: ezen parancs segítségével tudjuk a Vezérlőpult (\textit{Dashboard}) felületéről a kapcsolódást újrapróbálni
    
    \item \lstinline{refactorErl.dependencyGraph}: ezen parancs segítségével jelenítjük meg függőségi gráf nézetét a \textit{Command Palette}-ről kiadott utasítás alapján
    
    \item \lstinline{refactorErl.databaseSync}:  ezen parancs segítségével tudjuk a Vezérlőpult (\textit{Dashboard}) felületéről az adatbázis szinkronizációját elvégezni
    
    
    \item \lstinline{refactorErl.dynamicAnal}: ezen parancs segítségével tudjuk a Vezérlőpult (\textit{Dashboard}) felületéről az dinamikus függvényhívás elemzését elvégezni
    
    \item \lstinline{refactorErl.dynamicClear}: ezen parancs segítségével tudjuk a Vezérlőpult (\textit{Dashboard}) felületéről az dinamikus függvényhívás elemzésének eredményének törlését elvégezni
    
\end{itemize}


\subsubsection{\lstinline{refactorErlTreeView.ts}}

Ebben a fájlban a \lstinline{ReferlProvider} osztály implementációja és a hozzátartozó segéd típisuok, osztályok és interfészek.

\\
\vspace{14pt}
\textbf{ReferlProvider}
\\

Ez az osztály lényegében egy sablon, absztrakt osztály a beépített és az egyedi lekérdezéseknek. Implementálja a \lstinline{vscode.TreeDataProvider} interfészt. Vizsgáljuk meg a nyílvános részei.

\begin{itemize}
    \item \lstinline{refresh(data: any): void}: ezen függvénynek adhatjuk paraméterül a frissített adatot amit a fa nézetben megszeretnénk jeleníteni
    
    \item \lstinline{static selectTreeItem(rangeDescriptor: RangeDescriptor, decoration: vscode.TextEditorDecorationType, message: string)}: az első paraméterben megadott helyre állítja a szerkesztőt, majd a második paraméteréül kapott dekorációs stílusokat alkalmazza rá, s a harmadik paraméterben kapott üzenet lesz az az üzenet, ami akkor jelenik meg ha a felhasználó a kurzorát fölé viszi
\end{itemize}

\\
\vspace{14pt}
\textbf{ReferlTreeItem}
\\

Ez egy egyszerű fa elem, ami minimálisan a \lstinline{vscode.TreeItem} \footnote{https://code.visualstudio.com/api/references/vscode-api#TreeItem} osztályt bővíti ki. Lényegében egy konstruktora van, amiben rendre megadhatjuk a címet, az alcímet, összecsukási állapotot, a parancsot és az ikonok elérési útját, bár az utóbbi kettő nem kötelező.


\\
\vspace{14pt}
\textbf{ItemDescriptor}
\\

Egy interfész, amely az alábbi adattagok jelenlétét követeli meg:
\begin{itemize}
    \item \lstinline{title}: szöveg
    \item \lstinline{hasRange}: logikai
    \item \lstinline{subtitle}: szöveg
\end{itemize}


\\
\vspace{14pt}
\textbf{RangeCommand}
\\

Ez egy egyszerű fa elem, ami minimálisan a \lstinline{vscode.Command} \footnote{https://code.visualstudio.com/api/references/vscode-api#Command} osztályt bővíti ki. 
A konstruktorban lényegében egy \lstinline{ItemDescriptor} interfészt implementáló típust kell megadni ami a parancs argumentumja lesz. A parancshoz a \lstinline{"customQuery.goToLocation"} parancs lesz hozzákötve.


\\
\vspace{14pt}
\textbf{RangeDescriptor}
\\

Implementálja a lstinline{ItemDescriptor} interfészt. Konstruktora az alábbi paramáterezéssel hívható meg: 

\begin{itemize}
    \item \lstinline{fromLine} és \lstinline{fromCol}: számok, ez alapján beállítja a kezdő pozíciót egy \lstinline{vscode.Position}-be.
    
    \item \lstinline{toLine} és \lstinline{toCol}: számok, ez alapján beállítja a végződő pozíciót egy \lstinline{vscode.Position}-be.
    
    \item \lstinline{title}: cím
    
    \item \lstinline{file}: fájl elérése
    
    \item \lstinline{hoverInfo}: lebegő információ

\end{itemize}

\noindent Ezen kívül még az osztály \lstinline{subtitle} adattagjára beállítja a \lstinline{""}-t (\textit{üres sztring}).


\\
\vspace{14pt}
\textbf{NoPosDescriptor}
\\

Implementálja a \lstinline{ItemDescriptor} interfészt. Konstruktora egyetlen paramétert fogad, a címet, ami meg legyen jelenítve, hiszen ehez az osztályhoz nem tartozik pozíció így sem fájéra sem pedig lebegő információra nincsen szükség.

\noindent Ezen kívül még az osztály \lstinline{subtitle} adattagjára beállítja a \lstinline{"No source file"}-t, vagyis, hogy nincsen forrás fájl.






\\
\vspace{14pt}
\textbf{ResponseItem}
\\

Egy típus, amely az alábbi adattagokkal rendelkezik

\begin{itemize}
    \item \lstinline{fromPosLn: number}: kezdő sor információ
    
    \item \lstinline{fromPosCol: number}: kezdő oszlop információ
    
    \item \lstinline{toPosLn: number}: végződő sor információ
    
     \item \lstinline{toPosCol: number}: végződő oszlop információ
    
    \item \lstinline{name: string}: megjelenítendő név
    
    \item \lstinline{hoverInfo: string}: lebegő információ
    
     \item \lstinline{file: string}: fájl elérése
    
    \item \lstinline{noPos: boolean}: a tárolt pozíció adatok használhatóak e?

\end{itemize}







\\
\vspace{14pt}
\textbf{DataStorage}
\\

\noindent Egy interfész, amely az alábbi függvény implementálását követeli meg:

\noindent\lstinline{updateData(data: any): void}




\subsubsection{\lstinline{builtInQView.ts}}


\\
\vspace{14pt}
\textbf{BuiltInQViewProvider}
\\

Kiterjeszti a \lstinline{ReferlProvider} osztályt. Három függvénye van, amit lényegében a Visual Studio Code API-ja hív meg időről időre. Az egyik a \lstinline{getTreeItem}, ami lényegében visszaadja a paraméterül adott fa item-et. A másikodik pedig a \lstinline{getChildren} ami pedig egy fa item, gyerekeit számolja ki és adja vissza. A harmadik pedig a \lstinline{selectTreeItem} ami pedig alkalmazza rá a dekorációs stílust








\\
\vspace{14pt}
\textbf{SubTreeItem}
\\

Kiterjeszti a \lstinline{ReferlTreeItem} osztályt. Megadja az ikonját és a konstruktora rendre az alábbi paraméterekkel hívható: cím, alcím és az eredmény amihez kapcsolni szeretnénk. Ezen kívül opcionálisan megadható az ikon is, ha nem szeretnénk az alapértelmezetettet használni.





\\
\vspace{14pt}
\textbf{BuiltInQDataResponse}
\\


Egy típus, amely az alábbi adattagokkal rendelkezik

\begin{itemize}
    \item \lstinline{items: ResponseItem[]}: megjelenítendő adategységek listája
    
    \item \lstinline{variableName: string}: megjelenítendő név 
\end{itemize}



\\
\vspace{14pt}
\textbf{BuiltInQDataStorage}
\\

Implementálja a \lstinline{DataStorage} interfészt. Egyetlen adattagja van a \lstinline{data} ami egy \lstinline{BuiltInQDataResponse} típus. Ez használatos a belső adatreprezentációra. Nézzük meg a függvényeit:

\begin{itemize}
    \item \lstinline{updateData}: paraméteréül adhatjuk azt az adatot amire frissíteni szeretnénk a tárolt adatot.
    
    \item \lstinline{valid}: amennyiben a \lstinline{data} adattag nem \lstinline{undefined} úgy igazat ad vissza, ellenkező esetben hamisat
    
    \item \lstinline{items}: visszaadja a tárolt eredmény egységeket
    
    \item \lstinline{variableName}: a gyökér neve, amihez az adatok tartoznak az eredmények
    
    
\end{itemize}







\subsubsection{\lstinline{customQuery.ts}}

Az ebben a fájlban megvalósított osztályok nagyon hasonlítanak a \lstinline{builtInQView.ts} fájlban megvalósítottakhoz, azonban néhány apró helyen különböznek, amiket nem lehetett kiemelni a közös ősbe. Ezen különbségeket \textbf{félkövérrel} a legtöbb helyen kiemeltem.


\\
\vspace{14pt}
\textbf{CustomQueryProvider}
\\

Kiterjeszti a \lstinline{ReferlProvider} osztályt. Három függvénye van, amit lényegében a Visual Studio Code API-ja hív meg időről időre. Az egyik a \lstinline{getTreeItem}, ami lényegében visszaadja a paraméterül adott fa item-et. A másikodik pedig a \lstinline{getChildren} ami pedig egy fa item, gyerekeit számolja ki és adja vissza. A harmadik pedig a \lstinline{selectTreeItem} ami pedig alkalmazza rá a dekorációs stílust





\\
\vspace{14pt}
\textbf{CustomQuerySubTreeItem}
\\

Kiterjeszti a \lstinline{ReferlTreeItem} osztályt. Megadja az ikonját és a konstruktora rendre az alábbi paraméterekkel hívható: cím, alcím, az \textbf{összecsukás állapota} és az eredmény amihez kapcsolni szeretnénk. Ezen kívül opcionálisan megadható az ikon is, ha nem szeretnénk az alapértelmezetettet használni.





\\
\vspace{14pt}
\textbf{ResponseWrapper}
\\

Egy egyszerű típus, amelyre azért van, hogy \textbf{csoportosítsa az eredményeket fájlokként}, hiszen egyedi lekérdezések esetén fájlokként csoportosítjuk és az alábbi adattagokkal rendelkezik:

\begin{itemize}
    \item \lstinline{file: string}: a fájl
    
    \item \lstinline{items: ResponseItem[]}: a fájlhoz tartozó eredmények

\end{itemize}






\\
\vspace{14pt}
\textbf{CustomQueryDataResponse}
\\

Egy egyszerű típus, amely az alábbi adattagokkal rendelkezik:

\begin{itemize}
    \item \lstinline{request: string}: a lekérdezés
    
    \item \lstinline{response: ResponseWrapper[]}: a válaszok, eredmények

\end{itemize}








\\
\vspace{14pt}
\textbf{CustomQueryDataStorage}
\\


Implementálja a \lstinline{DataStorage} interfészt. Egyetlen adattagja van a \lstinline{data} ami egy \lstinline{CustomQueryDataResponse} típus. Ez használatos a belső adatreprezentációra. Nézzük meg a függvényeit:

\begin{itemize}
    \item \lstinline{updateData}: paraméteréül adhatjuk azt az adatot amire frissíteni szeretnénk a tárolt adatot.
    
    \item \lstinline{valid}: amennyiben a \lstinline{data} adattag nem \lstinline{undefined} úgy igazat ad vissza, ellenkező esetben hamisat. 
    
    \item \lstinline{request}: amennyiben van rendelkezésre álló adat, úgy a vissza adja azt a lekérdezést melyhez az eredmény tartozik
    
    \item \lstinline{files}: amennyiben van rendelkezésre álló adat, úgy a vissza adja azon fájlok neveit amihez adat tartozik.
    
    \item \lstinline{getResultsInFile}: amennyiben van rendelkezésre álló adat, úgy a vissza adja azon a eredmények listáját, ami az adott fájlhoz tartozik, amit paraméterben megadtunk. Ha ilyen fájl nincs akkor üres listával tér vissza.
    
    
\end{itemize}


\subsubsection{\lstinline{webSocketHandler.ts}}
A következőkben a kommunikáció legfontosabb elemével fogunk megismerkedni, azzal az osztállyal amelyik a Web Socketen keresztüli adatfolyamok küldésével, fogadásával és továbbküldésével foglalkozik. Itt továbbküldés alatt azt a tevékenységet értem, amikor a megfelelő vizuálizációs komponens felé küldi tovább. Tekintsük meg az osztálydiagrammot a \ref{fig:wsDiagram} ábrán, majd kiemelem a fontosabb részeket.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\linewidth]{images/wsDiagram.png}
  \caption{WebSocketHandler osztálydiagrammja}
  \label{fig:wsDiagram}
\end{figure}

Az osztály úgynevezett \textit{singleton} vagyis egyke tervezési mintát követ, tehát mindig csak egy példány lérezhet belőle. Ezt úgy lehet elérni, hogy a konstruktorját privát láthatóságúra állítjuk, így a példányosítása csakis osztályon belül lehetséges. A külső elérést a \lstinline{getInstance} metódus biztosítja, mely amennyiben már van egy példány visszadaj azt, amennyiben nincs létrehoz egyet.

Az osztály, s így a teljes bővítmény függ a \textit{jock} álltal fejlesztett SVG bővítménytől. \footnote{\url{https://marketplace.visualstudio.com/items?itemName=jock.svg}} ezen bővítmény segítségével jeleníti meg az SVG gráfokat.

\noindent Vegyük sorra az osztály publikus metódusait:

\begin{itemize}
    \item \lstinline{getInstance(): WebSocketHandler}: visszaadja az egyetlen példányt az osztályból 
    
    \item \lstinline{isConnected(): boolean}: megmondja, hogy van e aktív kapcsolat a Web Socketen keresztül
    
    \item \lstinline{connect(): Promise<any>}: ezzel kapcsolódhatunk a RefactorErl-hez Web Socketen keresztül. Helyes csatlakozés esetén az igíret (\textit{Promise}) feloldása esetén visszakapjuk az osztálypéldányt
    
    \item \lstinline{connectTryAgain(): Promise<any>}: annyiban más a \lstinline{connect()}-től, hogy megnézi azt, hogy van e kapcsolódási kísérlet folyamatban vagy sem, és folyamatason tájékoztatja a felhasználót a folyamatról. Lényegében amikor a felhasználó megnyomja a \textit{Try again} feliratú gombot a vezérlő pulton ez a metódus hívódik meg a háttérben.
    
    \item \lstinline{checkConnection(): Promise<boolean>}: leellenőrzi a Web Socket (WS) kapcsolatot a RefactorErl-el és erről tájékoztatja a felhasználót. Lényegében amikor a felhasználó megnyomja a \textit{Check connection} feliratú gombot a vezérlő pulton ez a metódus hívódik meg.
    
    \item \lstinline{aliveCheck(): Promise<boolean>}: ezzel a metódussal küldi el az \lstinline{alive} kérést a RefactorErl-nek.
    
    \item \lstinline{subscribe(event: string, fun: (p: any) => void: Promise<any>} feltudunk ezzel iratkozni egy esemény típusra, amit az első paraméterben tudunk megadni, a második paraméterében pedig az esemény lekezeléséhez használt függvényt kell megadni. \\ \\ A belső működése lényegében annyi, hogy egy szótár szerű objektumot tart karban aminek kulcsa az események típusai az értékek pedig az esemény kezelő függvények. Amikor egy bizonyos típusú esemény érkezik Web Socketen keresztül úgy ezen függvényeket sorban lefutatja, paraméterül adva az érkezett adatot.
    
    \item \lstinline{request(requestType: string, data: any): Promise<any>} ezen függvény segítségével tudunk kéréseket adni a RefactorErl felé. Az aszinkronitás kihasználása érdekében egy \textit{Promise} objektumot adunk vissza, ami tartalmazni fogja az eredményt ha elklészült. Paraméterül meg kell adnunk a lekérdezés típusát és az átküldendő adatot.

\end{itemize}

\subsubsection{\lstinline{dependencyGraphView.ts}}

A fájl két típust és egy osztályt definiál. Kezdjük a típusokkal először.



\\
\vspace{14pt}
\textbf{ViewState}
\\

Ez a típus reprezentál egy nézeti állapotot azálltal, hogy tárolja a gráf és az űrlap állapotát.

\begin{itemize}
    \item \lstinline{graph: GraphState | undefined}: a gráf állapota
    
    \item \lstinline{formState: DependencyGraphState | undefined: az űrlap állapota

\end{itemize}






\\
\vspace{14pt}
\textbf{GraphState}
\\

Ez a típus tárolja a gráf állapotát. Három lehetséges kombináció lehet:

\noindent \textbf{Amennyiben SVG kiemenetet kaptunk:}
\begin{itemize}
    \item \lstinline{status: "ok"}: a lekérdezés sikerességét indikálja
    \item \lstinline{type: "svg"}: a gráf típusát adja meg
    \item \lstinline{path: PathLike} egy elérési útvonalat ad meg az SVG fájlhoz
\end{itemize}

\noindent \textbf{Amennyiben szöveges kiemenetet kaptunk:}
\begin{itemize}
    \item \lstinline{status: "ok"}: a lekérdezés sikerességét indikálja
    \item \lstinline{type: "textual"}: a gráf típusát adja meg
    \item \lstinline{textualGraph: TextualGraph[]} a szöveges gráf elemeit tartalmazó lista
\end{itemize}


\noindent \textbf{Amennyiben hibát kaptunk:}
\begin{itemize}
    \item \lstinline{status: "failed"}: a lekérdezés sikerességét indikálja
    \item \lstinline{data: string}: a hiba okát, leírását tartalmazza
\end{itemize}


\\
\vspace{14pt}
\textbf{DependencyGraphView}
\\

Ez az osztály felelős a függőségi gráfok megjelenítésére szolgáló panel kezelésére. Ezen a panel a Visual Studio Code Webview API-ját használja. Az osztály a szerkesztő API dokumentációjában lévő leírás alapján készült \cite{webViewGuide} és az ottani kezdő projekten alapszik. \footnote{\url{https://github.com/microsoft/vscode-extension-samples/blob/main/webview-sample/README.md}}. 


\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{images/diagramDepg.png}
  \caption{DependencyGraphView osztálydiagrammja}
  \label{fig:diagramDepg}
\end{figure}

A \ref{fig:diagramDepg} ábrán láthatjuk az osztály felépítését, a függvények paraméterezését. A fontosabb metódusokról ejtsünk néhány szót.

\begin{itemize}
    \item \lstinline{postMessage}: ezzel a fügvénnyel tudunk adatot küldeni a Web View-ba.
    \item \lstinline{getHtmlForWebView}: Ennek a függvénynek a kimenete adja meg a HTML kódját a WebView-nak.
\end{itemize}


\subsubsection{\lstinline{depgraph.d.ts}}

A következő fájl egy érdekes darab. Ez egy típus definíciós fájl, ami külön ki lett emelve. Erre azért volt szükség, hogy az izoláltan futó Web View és kiegészítő fejlesztés folyamán azonos típus definíciókkal tudjun készülni, így elősegítve a típushelyes fejlesztést.

\\
\vspace{14pt}
\textbf{TextualGraph}
\begin{itemize}
    \item \lstinline{dependant: string}: az a gráf egység ami a függő. Ez lesz a nyíl baloldalán
    \item \lstinline{dependency: string}: az egység függőségei. Ez lesz a nyíl jobb oldalán.
\end{itemize}


\\
\vspace{14pt}
\textbf{PathLike} 
\\
Lényegében egy szinoníma a \lstinline{string}-re


\\
\vspace{14pt}
\textbf{GraphResponse}
\\

Ez a típus tárolja a gráf állapotát. Három lehetséges kombináció lehet:

\noindent Amennyiben SVG kiemenetet kaptunk:
\begin{itemize}
    \item \lstinline{status: "ok"}: a lekérdezés sikerességét indikálja
    \item \lstinline{type: "svg"}: a gráf típusát adja meg
    \item \lstinline{data: PathLike} egy elérési útvonalat ad meg az SVG fájlhoz
\end{itemize}

\noindent Amennyiben szöveges kiemenetet kaptunk:
\begin{itemize}
    \item \lstinline{status: "ok"}: a lekérdezés sikerességét indikálja
    \item \lstinline{type: "textual"}: a gráf típusát adja meg
    \item \lstinline{data: TextualGraph[]} a szöveges gráf elemeit tartalmazó lista
\end{itemize}


\noindent Amennyiben hibát kaptunk:
\begin{itemize}
    \item \lstinline{status: "failed"}: a lekérdezés sikerességét indikálja
    \item \lstinline{data: string}: a hiba okát, leírását tartalmazza
\end{itemize}


\\
\vspace{14pt}
\textbf{DependencyGraphState} 
\\ Az alábbi adattagokat definálja. Tartalmuk a RefactorErl Wiki oldalán pontosabban le vannak írva. \cite{referlWikiDependency}
\begin{itemize}
    \item \lstinline{type: string}: a gráf típusa
    \item \lstinline{level: string}: a gráf szintje
    \item \lstinline{starting_nodes: string[]}: kezdő pontok
    \item \lstinline{exclude_otp: boolean}: OTP kizárása
    \item \lstinline{exclude: string[]}: kizárt pontok
    \item \lstinline{exclude_lib: string[]}: kizárt könyvtárak
    \item \lstinline{connection: string[]}: kapcsolódása pontok
    \item \lstinline{output_type: string}: kimenet típusa
    
\end{itemize}




\\
\vspace{14pt}
\textbf{ExtensionMessageParam}

Olyan adattípus ami akkor használatos, amikor a bővítmény küldd üzenetet a WebView-nak

\begin{itemize}
    \item \lstinline{command: ExtensionMessageCommands}:
    \item \lstinline{graph?: TextualGraph[]}:
    \item \lstinline{error?: string}:
    \item \lstinline{data?: any}:
    \item \lstinline{path?: PathLike}:
\end{itemize}




\\
\vspace{14pt}
\textbf{ExtensionMessageCommands}
Ez a típus az alábbi értékek közül vehet fel egyet: \lstinline{ 'updateResponse' | 'printTextualGraph' | 'textualGraphError' | 'setForm' | 'svgGraphPath'}



\\
\vspace{14pt}
\textbf{WebViewMessageCommands}
Ez a típus az alábbi értékek közül vehet fel egyet: \lstinline{ 'dependencyGraph' | 'formState' | 'openSvg'}




\\
\vspace{14pt}
\textbf{WebViewMessageParam}
Ez a típus üzenet paramétere, amennyiben a Web View küldi el az üzenetet. Több féle szerkezetű lehet:

\noindent Amennyiben az űrlap állapotát küldi:
\begin{itemize}
    \item \lstinline{command: 'formState'}: a parancs típusa
    \item \lstinline{params: DependencyGraphState}: a parancs paramétere
\end{itemize}

\noindent Amennyiben az gráf generálásához szükséges paramétereket küldi:
\begin{itemize}
    \item \lstinline{command: 'dependencyGraph'}: a parancs típusa
    \item \lstinline{params: DependencyGraphState}: a parancs paramétere
\end{itemize}


\noindent Arra küldd kérdést, hogy a bővítmény nyisson meg egy SVG fájlt:
\begin{itemize}
    \item \lstinline{command: 'openSvg'}: a parancs típusa
    \item \lstinline{params: PathLike}: a parancs paramétere
\end{itemize}



\subsubsection{\lstinline{webviewMain.ts}}

Alapvetően a Web View-nak egy natív Java Scirpt fájlt lehet megadni, mint szkript fájl, azonban azt a  döntést hoztam, hogy a fejlesztése történjen Type Script-ben, így kitudom használni a típus ellenőrzéseket és közös típus interfészt tudok használni a bővítmény többi részével. Ahhoz, hogy ez műkdöjön természetesen elő kellett állítani a Java Script állományt, így a fordítási ciklusba beillesztettem egy komponens fordítást, így ennek fordított verziója is hiánytalanul előáll, és használható.

A fájl lényegében segéd függvényeket tartalmaz. Vegyük ezeket sorra:

\begin{itemize}
    \item \lstinline{semicolonSeparatedToArray(value: string)}: paraméteréül kapott pontosvessző álltal szeparált szöveget felbontja.
    
    \item \lstinline{postMessage(param: WebViewMessageParam)}: elküld egy üzenetet a bővítmény felé
    
    \item \lstinline{sendGraphRequest(event: MouseEvent)}: A \textit{Generate} feliratú gomb eseménykezelője. Ezen függvény alakítja át a paramétereket olyan formára, hogy a RefactorErl számára elküldhető legyen.
    
    \item \lstinline{handleExtensionMessages(event: MessageEvent)}: A bővítmény felől érkező üzeneteket kezeli le.
    
    \item \lstinline{clearGraph(event: MouseEvent)}: A gráfot letörli a fő munkafelületről
    
    \item \lstinline{printTextualGraph(graph: TextualGraph[])}: Kinyomtatja a fő munkaterületre a szöveges gráfot.
    
    \item \lstinline{adjustLevelLabelsOnForm()}: beállítja a címkéket az űrlapon, annak megfelelően, hogy a felhasználó milyen szintet választott ki.
    
    \item \lstinline{setForm(formState: DependencyGraphState)}: Paraméteréül kapott állapotot beállítja az űrlapon
    
    \item \lstinline{separateContent(content: string[]): string}: paraméterűül adott szting tömböt pontosvesszű álltal elválasztott szöveggé alakítja.
    
\end{itemize}


Végül történik egy kis össze állítás, mikor is a különbözö HTML elemek eseményeire az eseménykezelők rá lesznek kötve.


\subsubsection{Kommunikáció a többi komponenssel}

A Visualiser komponens csak a RefactorErl-el kommunikál Web Socketen keresztül.



\section{Teljes alkalmazás tesztelése}

Az automatikus tetszteket az egység tesztek szintjéig sikerült kivitelezni, de mivel két komplex rendszer összekötéséről van szó ezért rengeteg funkcionalitás csak manuálisan tesztelhető. A következőkben a manuális rendszer szintű tesztelés eseteit és eredményeit fogjuk áttekinteni

\subsection{Diagnosztikák tesztelése}

Ebben a részben a diagnosztikák tesztelésével fogunk foglalkozni, ahol is az Erlang LS és a RefactorErl integrációját teszteljük.

\noindent Tekintsük az alábbi teszt fájlt:

\lstset{caption=\lstinline{show.erl} teszt fájl, label=src:erlang} \label{testShowERL}
\begin{lstlisting}[language={erlang}]  
-module(show).
-export([safe_os_call/0, unsafe_os_call/1]).
-define(EXAMPLE_MACRO, 67).

safe_os_call() ->
    os:cmd("ls").

unsafe_os_call(A) ->
    os:cmd(A).
\end{lstlisting}

Ebben az esetben két diagnosztika aktív: \textit{nem használt makrók detektálása} és a \textit{nem biztonságos OS modul hívások}. Amint a \ref{testShowERL} forrásban láthatjuk a harmadik sorban van egy nem használt makró, illetve a kilencedik sorban egy nem biztonságos hívás. Azt várjuk el, hogy ezen sorokat jelezze a rendszer.

\noindent Először ellenőrizzük le, hogy a RefactorErl Shell felületéből ezen információk valóban megérkeznek.

\lstset{caption=\lstinline{show.erl} teszt fájl diagnosztikai eredményei, label=src:sh} \label{testShowSHELL}
\begin{lstlisting}[language={sh}]  
(referl@fikoMac)26> ri:ls().                                        
{{ok,["/Users/fikorobert/Projects/ELS_Referl/els_dev/show.erl"]},{error,[]}}
ok
(referl@fikoMac)27> ri:q("mods[name=show].funs.unsecure_os_call").  
show:unsafe_os_call/1
    os:cmd(A)
ok
(referl@fikoMac)28> ri:q("mods[name=show].macros[not .references]").
show.erl
    EXAMPLE_MACRO
ok
\end{lstlisting}

A \ref{testShowSHELL} részleten láthatjuk, hogy a fájl megfelelően be lett töltve, majd az első lekérdezés valóban vissza adja a \lstinline{show:unsafe_os_call/1}-t miben van egy nem biztonságos hívás, mégpedig a \lstinline{os:cmd(A)}. A második lekérdezés pedig valóban visszaadja azt, hogy tényleg az \lstinline{EXAMPLE_MACRO} nincs használéatban.

\noindent Következő lépésben nyissuk meg a Visual Studio Code-ot és vessük össze az eredményt.

\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{images/testCases/showUnsecure.png}
  \caption{Nem biztonságos hívás a \textit{show} modulban}
  \label{fig:showUnsecure}
\end{figure}


\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{images/testCases/showMacro.png}
  \caption{Nem használt makró a \textit{show} modulban}
  \label{fig:showMacro}
\end{figure}

Láthatjuk a \ref{fig:showUnsecure} és a \ref{fig:showMacro} ábrán, hogy valóban azok a diagnosztikák jelennek meg azon függvényeknél, amit elvárunk a Shell-es kimenet alapján.

\subsection{Kódakciók helyes megjelenítésének ellenőrzése} \label{codeactionIntro}

A kövezkező a tesztesetekben az Erlang LS és a RefactorErl, illetve a Visualiser komponens kapcsolatát teszteljük, azálltal, hogy azon kódakciókat leteszteljük.


Első lépésnek ellenőrizzük le azt, hogy amenyiben a RefactorErl nem fut, valóban nem ad felesleges végre hajtásra nem alkalmas kódakciókat, ehhez az alábbi parancsot futtattam: \lstinline{epmd -names} a visszatérési listában ellenőrizzük le, hogy valóban nem fut RefactorErl példány. 

Következő lépésnek indítsuk el a Visual Studio Code-ot. Jobb alsó sarokban meg is kapjuk az értesítést, hogy \textit{RefactorErl is not connected}, s ha egy változó felé visszük a kurzort valóban nem kapunk kódakció javaslatot. Ezt ellenőrizzük le a függvény definíciók és modul definíciók esetében is. A következő képernyő fotókon (\ref{fig:NoCodeActFun}, \ref{fig:NoCodeActVar}, \ref{fig:NoCodeActMod} és \ref{fig:NoCodeActApp}) láthatjuk azt, hogy valóban nem kapunk kódakció javaslatokat.


\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\linewidth]{images/testCases/NoCodeActVar.png}
  \caption{Nincsen kódakció változó esetében}
  \label{fig:NoCodeActVar}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\linewidth]{images/testCases/NoCodeActFun.png}
  \caption{Nincsen kódakció függvény definíció esetében}
  \label{fig:NoCodeActFun}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\linewidth]{images/testCases/NoCodeActMod.png}
  \caption{Nincsen kódakció modul definíció esetében}
  \label{fig:NoCodeActMod}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\linewidth]{images/testCases/NoCodeActApp.png}
  \caption{Nincsen kódakció függvény hívás esetében}
  \label{fig:NoCodeActApp}
\end{figure}

Következő lépésben indítsuk el a RefactorErl-t. Majd a fájl újratöltése után megjelennek a kódakciók.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\linewidth]{images/testCases/CodeActVar.png}
  \caption{Kódakció változó esetében}
  \label{fig:CodeActVar}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\linewidth]{images/testCases/CodeActFun.png}
  \caption{Kódakció függvény definíció esetében}
  \label{fig:CodeActFun}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\linewidth]{images/testCases/CodeActMod.png}
  \caption{Kódakció modul definíció esetében}
  \label{fig:CodeActMod}
\end{figure}

\begin{figure}[H]
  \centering
  \includegraphics[width=0.7\linewidth]{images/testCases/CodeActApp.png}
  \caption{Kódakció függvény hívás esetében}
  \label{fig:CodeActApp}
\end{figure}

A \ref{fig:CodeActFun}, \ref{fig:CodeActVar}, \ref{fig:CodeActMod} és \ref{fig:CodeActApp} ábrákon láthatjuk, hogy megjelentek a kódakciók, s ez teljes mértékben az elvárt működést prezentálja. 

\textit{Megjegyzés: sajnos a \ref{fig:CodeActApp} ábrán a \lstset{execute} függvény hívása nem látszik, mert pont kitakarja a kódackió menüje, de \ref{fig:NoCodeActApp} ábrán látható a kitakart terület. }



\subsection{Változó Origin értékének kiszámításának tesztelése}

Korábbiakban (\ref{codeactionIntro} részben) ellenőriztük, hogy valóban megjelennek a kódakciók, így ezek helyes működését a következő kódakciókkal kapcsolatos teszt esetekben feltételezzük.

\noindent Ehhez az alábbi teszt fájlt használjuk:

\lstset{caption=\lstinline{variables.erl} teszt fájl, label=src:erlang} \label{testVariablesERL}
\begin{lstlisting}[language={erlang}]  
-module(variables).
-export([alpha/1]).

alpha(John) -> beta(John).

beta(James) -> 
    gamma(James), 
    delta(James).

gamma(_Alisson) -> ok.

delta(Jane) -> execute(Jane).

execute(Emil) -> {ok, Emil}.
\end{lstlisting}

A \ref{testVariablesERL} forrás 14. sorában levő visszatérési \lstinline{Emil} változó Origin értékét szeretnénk kiszámítani


\begin{figure}[H]
  \centering
  \includegraphics[width=0.9\linewidth]{images/testCases/testVarOr.png}
  \caption{Origin kódakció eredményei}
  \label{fig:testVarOr}
\end{figure}


Láthatjuk, a \ref{fig:testVarOr} ábrán, hogy a jobb oldalon meg is jelentek a lehetséges Origin értékek, amik megegyeznek a \ref{testOriginShell} kimenetben találhatóakkal


\lstset{caption=Válltozó Origin értéke Shellből, label=src:sh} \label{testOriginShell}
\begin{lstlisting}[language={sh}]  
(referl@fikoMac)27> ri:q("mods[name=variables].funs[name=execute].vars[name=Emil].refs.origin").    
Emil
    James
    James
    Jane
    Jane
    Emil
    Emil
    John
    John
ok
\end{lstlisting}


\subsection{Változó Reach értékének kiszámításának tesztelése}


Korábbiakban (\ref{codeactionIntro} részben) ellenőriztük, hogy valóban megjelennek a kódakciók, így ezek helyes működését a következő kódakciókkal kapcsolatos teszt esetekben feltételezzük.

\noindent Ehhez szintén a \ref{testVariablesERL} fájlt használjuk.
 

A \ref{testVariablesERL} forrás 6. sorában levő visszatérési \lstinline{James} változó Reach értékét szeretnénk kiszámítani


\begin{figure}[H]
  \centering
  \includegraphics[width=0.9\linewidth]{images/testCases/testVarReach.png}
  \caption{Reach kódakció eredményei}
  \label{fig:testVarReach}
\end{figure}


Láthatjuk, a \ref{fig:testVarReach} ábrán, hogy a jobb oldalon meg is jelentek a lehetséges Reach értékek, amik megegyeznek a \ref{testReachShell} kimenetben találhatóakkal


\lstset{caption=Válltozó Origin értéke Shellből, label=src:sh} \label{testReachShell}
\begin{lstlisting}[language={sh}]  
(referl@fikoMac)29> ri:q("mods[name=variables].funs[name=beta].vars[name=James].bindings.reach"). 
James
    James
    James
    James
    Jane
    Jane
    Emil
    Emil
    _Alisson
ok
\end{lstlisting}


\subsection{Függvény függőségi gráfjának generálásának tesztelése}

\lstset{caption=\lstinline{dependency.erl} teszt fájl, label=src:erlang} \label{testdependencyERL}
\begin{lstlisting}[language={erlang}]  
-module(dependency).

len(List) ->
    length(List).

isHundered(List) ->
    hello(),
    case len(List) of
        100 -> true;
        _ -> false
    end.

hello() ->
    io:format("Hello World!").
\end{lstlisting}

A \ref{testdependencyERL} forrásban, ha a \lstinline{isHundered/1} függvénye fölé állunk, és onnan kérünk egy függőségi gráfot, akkor ezt az eredményt kapjuk:

\begin{figure}[H]
  \centering
  \includegraphics[width=\linewidth]{images/testCases/funDep.png}
  \caption{Függvény függőség kódakció eredményei}
  \label{fig:funDep}
\end{figure}


\lstset{caption=Függvány függőség lekérdezésének eredménye, label=src:sh} \label{testDepFunSHELL}
\begin{lstlisting}[language={sh}]  
(referl@fikoMac)2> ri:print_dep([{level, func}, {starting_nodes, ["dependency:isHundered/1"]}]).
{ok,[{"dependency:hello/0",["io:format/1"]},
     {"dependency:isHundered/1",
      ["dependency:len/1","dependency:hello/0"]},
     {"dependency:len/1",["erlang:length/1"]},
     {"io:format/1",[]},
     {"erlang:length/1",[]}]}
\end{lstlisting}


Ha összevetjük a \ref{fig:funDep} ábrán látható eredményt a \ref{testDepFunSHELL} Erlang Shell-beli eredményével, akkor láthatjuk, hogy ugyan azt az információt kaptuk. Ugye ami a nyíl előtti részen van, az a pár első komponense, míg a nyíl utáni rész a pár második komponense.


\subsection{Modul függőségi gráfjának generálásának tesztelése}

A modul függőségek tesztelésének is a \ref{testdependencyERL} fájlt fogjuk használni, hiszen ez a fájl modul szinten függ az \lstinline{erlang} és a \lstinline{io} moduloktól is, nézzük meg ezt először egy RefactorErl Shell interfészbeli lekérdezés segítségével.

\lstset{caption=Függvány függőség lekérdezésének eredménye, label=src:sh} \label{testDepFunSHELL2}
\begin{lstlisting}[language={sh}]  
(referl@fikoMac)3> ri:print_dep([{level, mod}, {starting_nodes, ["dependency"]}]).              
{ok,[{"erlang",[]},
     {"dependency",["io","erlang"]},
     {"io",[]}]}
\end{lstlisting}

A \ref{testDepFunSHELL2} Shell részlet alapjána a függőségi feltevélseink megerősíthetőek, nézzük meg, hogy a kódakciók is ugyanezt az eredményt hozzák e. Álljunk a kurzorral a modul definíció főle, majd válasszuk a \textit{Dependency graph from dependency} opciót, ahol itt a kis betűvel szedett \textit{dependency} a modul neve. 


\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\linewidth]{images/testCases/depMod.png}
  \caption{Modul függőség kódakció eredményei}
  \label{fig:depMod}
\end{figure}

A \ref{fig:depMod} ábrán is látható, hogy a megfelelő eredményt kaptuk. Ezzel a módszerrel az űrlap alapján történő generálást is leteszteltük, hiszen az Erlang LS csak a paramétereket küldi meg a generáláshoz, a kérés elküldése a Visualiser komponens feladata.


\subsection{Függvény dinamikus hívásainak tesztelése}

A dinamikus függvény hívások teszteléséhez az alábbi \ref{testDynCallERL} fájlt fogjuk használni.

\lstset{caption=\lstinline{calls.erl} teszt fájl, label=src:erlang} \label{testDynCallERL}
\begin{lstlisting}[language={erlang}]  
-module(calls).

dyncall() ->
    apply(calls, test, []).

call() ->
    test().

test() ->
    hello.
\end{lstlisting}

Tekintsük meg a következő \ref{testDynCallSHELL} Shell részletet. Láthatjuk, hogy a \lstinline{test} nevű függvény egyszer teszt formájában meghívásra kerül, míg máskor \lstinline{apply/3} segítségével értékelődik ki.


\lstset{caption=Függvény dinamikus hívásainak lekérdezésének eredménye, label=src:sh} \label{testDynCallSHELL}
\begin{lstlisting}[language={sh}]  
(referl@fikoMac)7> ri:q("mods[name=calls].funs[name=test].references").
calls:test/0
    apply(calls, test, [])
    test()
ok
\end{lstlisting}

A következő \ref{fig:dynCall} ábrán is látható, hogy a megfelelő eredményt kaptuk.

\begin{figure}[H]
  \centering
  \includegraphics[width=0.8\linewidth]{images/testCases/dynCall.png}
  \caption{Modul függőség kódakció eredményei}
  \label{fig:dynCall}
\end{figure}


